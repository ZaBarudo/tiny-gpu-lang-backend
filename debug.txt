Args: llc -march=tinygpu -O0 index6.ll -debug -view-isel-dags -o index.S 

Features:
CPU:generic
TuneCPU:generic

[SafeStack] Function: _Z6branchii
[SafeStack]     safestack is not requested for this function
Skipping pass 'CPU0 DAG->DAG Pattern Instruction Selection' on function _Z6branchii
	FastISel is enabled



=== _Z6branchii
Enabling fast-isel
Found argument copy elision candidate:   %a.addr = alloca i32, align 4
Found argument copy elision candidate:   %b.addr = alloca i32, align 4
Creating new node: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Creating new node: t4: i32,ch = CopyFromReg t0, Register:i32 %1
Creating constant: t6: i32 = Constant<0>
Creating new node: t7: i32 = undef
Creating new node: t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32
Creating new node: t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
Creating new node: t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32
Creating new node: t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32
Creating new node: t14: i1 = setcc t11, t12, setne:ch
Creating constant: t15: i1 = Constant<-1>
Creating new node: t16: i1 = xor t14, Constant:i1<-1>
Creating new node: t18: ch = brcond t10, t16, BasicBlock:ch<if.else 0x6268cc119358>
Creating new node: t20: ch = br t18, BasicBlock:ch<if.then 0x6268cc119238>

Initial selection DAG: %bb.0 '_Z6branchii:entry'
SelectionDAG has 21 nodes:
  t0: ch,glue = EntryToken
  t6: i32 = Constant<0>
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32
    t4: i32,ch = CopyFromReg t0, Register:i32 %1
  t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
          t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32
          t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32
        t14: i1 = setcc t11, t12, setne:ch
      t16: i1 = xor t14, Constant:i1<-1>
    t18: ch = brcond t10, t16, BasicBlock:ch<if.else 0x6268cc119358>
  t20: ch = br t18, BasicBlock:ch<if.then 0x6268cc119238>



Combining: t20: ch = br t18, BasicBlock:ch<if.then 0x6268cc119238>

Combining: t19: ch = BasicBlock<if.then 0x6268cc119238>

Combining: t18: ch = brcond t10, t16, BasicBlock:ch<if.else 0x6268cc119358>
Creating new node: t22: i1 = setcc t11, t12, seteq:ch
Creating new node: t23: ch = brcond t10, t22, BasicBlock:ch<if.else 0x6268cc119358>
 ... into: t23: ch = brcond t10, t22, BasicBlock:ch<if.else 0x6268cc119358>

Combining: t23: ch = brcond t10, t22, BasicBlock:ch<if.else 0x6268cc119358>
Creating new node: t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x6268cc119358>
 ... into: t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x6268cc119358>

Combining: t21: ch = seteq

Combining: t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x6268cc119358>

Combining: t20: ch = br t24, BasicBlock:ch<if.then 0x6268cc119238>

Combining: t17: ch = BasicBlock<if.else 0x6268cc119358>

Combining: t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32

Combining: t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32

Combining: t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32

Combining: t9: i32 = FrameIndex<2>

Combining: t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32

Combining: t7: i32 = undef

Combining: t5: i32 = FrameIndex<1>

Combining: t4: i32,ch = CopyFromReg t0, Register:i32 %1

Combining: t3: i32 = Register %1

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %0

Combining: t1: i32 = Register %0

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.0 '_Z6branchii:entry'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32
    t4: i32,ch = CopyFromReg t0, Register:i32 %1
  t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
      t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32
      t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32
    t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x6268cc119358>
  t20: ch = br t24, BasicBlock:ch<if.then 0x6268cc119238>



Legalizing node: t21: ch = seteq
Analyzing result type: ch
Legal result type
Legally typed node: t21: ch = seteq

Legalizing node: t19: ch = BasicBlock<if.then 0x6268cc119238>
Analyzing result type: ch
Legal result type
Legally typed node: t19: ch = BasicBlock<if.then 0x6268cc119238>

Legalizing node: t17: ch = BasicBlock<if.else 0x6268cc119358>
Analyzing result type: ch
Legal result type
Legally typed node: t17: ch = BasicBlock<if.else 0x6268cc119358>

Legalizing node: t9: i32 = FrameIndex<2>
Analyzing result type: i32
Legal result type
Legally typed node: t9: i32 = FrameIndex<2>

Legalizing node: t7: i32 = undef
Analyzing result type: i32
Legal result type
Legally typed node: t7: i32 = undef

Legalizing node: t5: i32 = FrameIndex<1>
Analyzing result type: i32
Legal result type
Legally typed node: t5: i32 = FrameIndex<1>

Legalizing node: t3: i32 = Register %1
Ignoring node results
Legally typed node: t3: i32 = Register %1

Legalizing node: t1: i32 = Register %0
Ignoring node results
Legally typed node: t1: i32 = Register %0

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i32,ch = CopyFromReg t0, Register:i32 %0

Legalizing node: t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Legal operand
Analyzing operand: t5: i32 = FrameIndex<1>
Legal operand
Analyzing operand: t7: i32 = undef
Legal operand
Legally typed node: t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32

Legalizing node: t4: i32,ch = CopyFromReg t0, Register:i32 %1
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t4: i32,ch = CopyFromReg t0, Register:i32 %1

Legalizing node: t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
Analyzing result type: ch
Legal result type
Analyzing operand: t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32
Legal operand
Analyzing operand: t4: i32,ch = CopyFromReg t0, Register:i32 %1
Legal operand
Analyzing operand: t9: i32 = FrameIndex<2>
Legal operand
Analyzing operand: t7: i32 = undef
Legal operand
Legally typed node: t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32

Legalizing node: t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
Legal operand
Analyzing operand: t5: i32 = FrameIndex<1>
Legal operand
Analyzing operand: t7: i32 = undef
Legal operand
Legally typed node: t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32

Legalizing node: t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
Legal operand
Analyzing operand: t9: i32 = FrameIndex<2>
Legal operand
Analyzing operand: t7: i32 = undef
Legal operand
Legally typed node: t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32

Legalizing node: t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x6268cc119358>
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
Legal operand
Analyzing operand: t21: ch = seteq
Legal operand
Analyzing operand: t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32
Legal operand
Analyzing operand: t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32
Legal operand
Analyzing operand: t17: ch = BasicBlock<if.else 0x6268cc119358>
Legal operand
Legally typed node: t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x6268cc119358>

Legalizing node: t20: ch = br t24, BasicBlock:ch<if.then 0x6268cc119238>
Analyzing result type: ch
Legal result type
Analyzing operand: t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x6268cc119358>
Legal operand
Analyzing operand: t19: ch = BasicBlock<if.then 0x6268cc119238>
Legal operand
Legally typed node: t20: ch = br t24, BasicBlock:ch<if.then 0x6268cc119238>

Legalizing node: t65535: ch = handlenode t20
Analyzing result type: ch
Legal result type
Analyzing operand: t20: ch = br t24, BasicBlock:ch<if.then 0x6268cc119238>
Legal operand
Legally typed node: t65535: ch = handlenode t20

Type-legalized selection DAG: %bb.0 '_Z6branchii:entry'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32
    t4: i32,ch = CopyFromReg t0, Register:i32 %1
  t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
      t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32
      t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32
    t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x6268cc119358>
  t20: ch = br t24, BasicBlock:ch<if.then 0x6268cc119238>



Legalizing: t20: ch = br t24, BasicBlock:ch<if.then 0x6268cc119238>
Legal node: nothing to do

Legalizing: t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x6268cc119358>
Legal node: nothing to do

Legalizing: t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32
Legalizing non-extending load operation

Legalizing: t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32
Legalizing non-extending load operation

Legalizing: t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t4: i32,ch = CopyFromReg t0, Register:i32 %1
Legal node: nothing to do

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Legal node: nothing to do

Legalizing: t21: ch = seteq
Legal node: nothing to do

Legalizing: t19: ch = BasicBlock<if.then 0x6268cc119238>
Legal node: nothing to do

Legalizing: t17: ch = BasicBlock<if.else 0x6268cc119358>
Legal node: nothing to do

Legalizing: t9: i32 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t7: i32 = undef
Legal node: nothing to do

Legalizing: t5: i32 = FrameIndex<1>
Legal node: nothing to do

Legalizing: t3: i32 = Register %1

Legalizing: t1: i32 = Register %0

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.0 '_Z6branchii:entry'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32
    t4: i32,ch = CopyFromReg t0, Register:i32 %1
  t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
      t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32
      t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32
    t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x6268cc119358>
  t20: ch = br t24, BasicBlock:ch<if.then 0x6268cc119238>



Legalizing: t20: ch = br t24, BasicBlock:ch<if.then 0x6268cc119238>
Legal node: nothing to do

Combining: t20: ch = br t24, BasicBlock:ch<if.then 0x6268cc119238>

Legalizing: t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x6268cc119358>
Legal node: nothing to do

Combining: t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x6268cc119358>

Legalizing: t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32
Legalizing non-extending load operation

Combining: t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32

Legalizing: t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32
Legalizing non-extending load operation

Combining: t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32

Legalizing: t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32

Legalizing: t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32

Legalizing: t4: i32,ch = CopyFromReg t0, Register:i32 %1
Legal node: nothing to do

Combining: t4: i32,ch = CopyFromReg t0, Register:i32 %1

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Legal node: nothing to do

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %0

Legalizing: t21: ch = seteq
Legal node: nothing to do

Combining: t21: ch = seteq

Legalizing: t19: ch = BasicBlock<if.then 0x6268cc119238>
Legal node: nothing to do

Combining: t19: ch = BasicBlock<if.then 0x6268cc119238>

Legalizing: t17: ch = BasicBlock<if.else 0x6268cc119358>
Legal node: nothing to do

Combining: t17: ch = BasicBlock<if.else 0x6268cc119358>

Legalizing: t9: i32 = FrameIndex<2>
Legal node: nothing to do

Combining: t9: i32 = FrameIndex<2>

Legalizing: t7: i32 = undef
Legal node: nothing to do

Combining: t7: i32 = undef

Legalizing: t5: i32 = FrameIndex<1>
Legal node: nothing to do

Combining: t5: i32 = FrameIndex<1>

Legalizing: t3: i32 = Register %1

Combining: t3: i32 = Register %1

Legalizing: t1: i32 = Register %0

Combining: t1: i32 = Register %0

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.0 '_Z6branchii:entry'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32
    t4: i32,ch = CopyFromReg t0, Register:i32 %1
  t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
      t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32
      t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32
    t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x6268cc119358>
  t20: ch = br t24, BasicBlock:ch<if.then 0x6268cc119238>


Writing '/tmp/dag._Z6branchii-7cbe4a.dot'...  done. 
Trying 'xdg-open' program... Remember to erase graph file: /tmp/dag._Z6branchii-7cbe4a.dot
===== Instruction selection begins: %bb.0 'entry'

ISEL: Starting selection on root node: t20: ch = br t24, BasicBlock:ch<if.then 0x6268cc119238>
ISEL: Starting pattern match
  Morphed node: t20: ch = BRNCH BasicBlock:ch<if.then 0x6268cc119238>, t24
ISEL: Match complete!

ISEL: Starting selection on root node: t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x6268cc119358>
ISEL: Starting pattern match
  Initial Opcode index to 365
  Skipped scope entry (due to false predicate) at index 369, continuing at 395
  Skipped scope entry (due to false predicate) at index 396, continuing at 422
  Skipped scope entry (due to false predicate) at index 423, continuing at 449
  Skipped scope entry (due to false predicate) at index 450, continuing at 476
  Skipped scope entry (due to false predicate) at index 477, continuing at 503
Creating new machine node: t25: i32 = CMP t11, t12
  Created node: t25: i32 = CMP t11, t12
  Morphed node: t24: ch = BRNCHZ t25, BasicBlock:ch<if.else 0x6268cc119358>, t10
ISEL: Match complete!

ISEL: Starting selection on root node: t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32
ISEL: Starting pattern match
  Initial Opcode index to 254
  Morphed node: t11: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> FrameIndex:i32<1>, t10
ISEL: Match complete!

ISEL: Starting selection on root node: t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32
ISEL: Starting pattern match
  Initial Opcode index to 254
  Morphed node: t12: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> FrameIndex:i32<2>, t10
ISEL: Match complete!

ISEL: Starting selection on root node: t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
ISEL: Starting pattern match
  Initial Opcode index to 53
  Match failed at index 59
  Continuing at 77
  Morphed node: t10: ch = STR<Mem:(store (s32) into %ir.b.addr)> t4, FrameIndex:i32<2>, t8
ISEL: Match complete!

ISEL: Starting selection on root node: t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32
ISEL: Starting pattern match
  Initial Opcode index to 53
  Match failed at index 59
  Continuing at 77
  Morphed node: t8: ch = STR<Mem:(store (s32) into %ir.a.addr)> t2, FrameIndex:i32<1>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i32,ch = CopyFromReg t0, Register:i32 %1

ISEL: Starting selection on root node: t2: i32,ch = CopyFromReg t0, Register:i32 %0

ISEL: Starting selection on root node: t19: ch = BasicBlock<if.then 0x6268cc119238>

ISEL: Starting selection on root node: t17: ch = BasicBlock<if.else 0x6268cc119358>

ISEL: Starting selection on root node: t9: i32 = FrameIndex<2>
ISEL: Starting pattern match
  Initial Opcode index to 347
Creating constant: t27: i32 = TargetConstant<0>
  Morphed node: t9: i32 = ADDI TargetFrameIndex:i32<2>, TargetConstant:i32<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t5: i32 = FrameIndex<1>
ISEL: Starting pattern match
  Initial Opcode index to 347
  Morphed node: t5: i32 = ADDI TargetFrameIndex:i32<1>, TargetConstant:i32<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t3: i32 = Register %1

ISEL: Starting selection on root node: t1: i32 = Register %0

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:

Selected selection DAG: %bb.0 '_Z6branchii:entry'
SelectionDAG has 19 nodes:
  t0: ch,glue = EntryToken
  t5: i32 = ADDI TargetFrameIndex:i32<1>, TargetConstant:i32<0>
  t9: i32 = ADDI TargetFrameIndex:i32<2>, TargetConstant:i32<0>
    t4: i32,ch = CopyFromReg t0, Register:i32 %1
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t8: ch = STR<Mem:(store (s32) into %ir.a.addr)> t2, t5, t0
  t10: ch = STR<Mem:(store (s32) into %ir.b.addr)> t4, t9, t8
        t11: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> t5, t10
        t12: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> t9, t10
      t25: i32 = CMP t11, t12
    t24: ch = BRNCHZ t25, BasicBlock:ch<if.else 0x6268cc119358>, t10
  t20: ch = BRNCH BasicBlock:ch<if.then 0x6268cc119238>, t24


********** List Scheduling %bb.0 'entry' **********
SU(0): t20: ch = BRNCH BasicBlock:ch<if.then 0x6268cc119238>, t24

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t24: ch = BRNCHZ t25, BasicBlock:ch<if.else 0x6268cc119358>, t10

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 1
  Predecessors:
    SU(8): Data Latency=1
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t10: ch = STR<Mem:(store (s32) into %ir.b.addr)> t4, t9, t8

  # preds left       : 3
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 4
  Predecessors:
    SU(7): Data Latency=1
    SU(6): Data Latency=1
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=1 Barrier
    SU(9): Ord  Latency=1 Barrier
    SU(10): Ord  Latency=1 Barrier
SU(3): t8: ch = STR<Mem:(store (s32) into %ir.a.addr)> t2, t5, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
    SU(5): Data Latency=1
    SU(4): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
SU(4): t5: i32 = ADDI TargetFrameIndex:i32<1>, TargetConstant:i32<0>

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(3): Data Latency=1
    SU(10): Data Latency=1
SU(5): t2: i32,ch = CopyFromReg t0, Register:i32 %0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(3): Data Latency=1
SU(6): t9: i32 = ADDI TargetFrameIndex:i32<2>, TargetConstant:i32<0>

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=1
    SU(9): Data Latency=1
SU(7): t4: i32,ch = CopyFromReg t0, Register:i32 %1

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=1
SU(8): t25: i32 = CMP t11, t12

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 2
  Predecessors:
    SU(10): Data Latency=1
    SU(9): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(9): t12: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> t9, t10

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 3
  Predecessors:
    SU(6): Data Latency=1
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(8): Data Latency=1
SU(10): t11: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> t5, t10

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(8): Data Latency=1

Examining Available:
Height 0: SU(0): t20: ch = BRNCH BasicBlock:ch<if.then 0x6268cc119238>, t24


*** Scheduling [0]: SU(0): t20: ch = BRNCH BasicBlock:ch<if.then 0x6268cc119238>, t24


Examining Available:
Height 1: SU(1): t24: ch = BRNCHZ t25, BasicBlock:ch<if.else 0x6268cc119358>, t10


*** Scheduling [1]: SU(1): t24: ch = BRNCHZ t25, BasicBlock:ch<if.else 0x6268cc119358>, t10


Examining Available:
Height 2: SU(8): t25: i32 = CMP t11, t12


*** Scheduling [2]: SU(8): t25: i32 = CMP t11, t12


Examining Available:
Height 3: SU(9): t12: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> t9, t10

Height 3: SU(10): t11: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> t5, t10


*** Scheduling [3]: SU(9): t12: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> t9, t10


Examining Available:
Height 3: SU(10): t11: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> t5, t10


*** Scheduling [4]: SU(10): t11: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> t5, t10


Examining Available:
Height 5: SU(2): t10: ch = STR<Mem:(store (s32) into %ir.b.addr)> t4, t9, t8


*** Scheduling [5]: SU(2): t10: ch = STR<Mem:(store (s32) into %ir.b.addr)> t4, t9, t8


Examining Available:
Height 6: SU(6): t9: i32 = ADDI TargetFrameIndex:i32<2>, TargetConstant:i32<0>

Height 6: SU(3): t8: ch = STR<Mem:(store (s32) into %ir.a.addr)> t2, t5, t0

Height 6: SU(7): t4: i32,ch = CopyFromReg t0, Register:i32 %1


*** Scheduling [6]: SU(6): t9: i32 = ADDI TargetFrameIndex:i32<2>, TargetConstant:i32<0>


Examining Available:
Height 6: SU(3): t8: ch = STR<Mem:(store (s32) into %ir.a.addr)> t2, t5, t0

Height 6: SU(7): t4: i32,ch = CopyFromReg t0, Register:i32 %1


*** Scheduling [7]: SU(3): t8: ch = STR<Mem:(store (s32) into %ir.a.addr)> t2, t5, t0


Examining Available:
Height 8: SU(4): t5: i32 = ADDI TargetFrameIndex:i32<1>, TargetConstant:i32<0>

Height 8: SU(5): t2: i32,ch = CopyFromReg t0, Register:i32 %0

Height 6: SU(7): t4: i32,ch = CopyFromReg t0, Register:i32 %1


*** Scheduling [8]: SU(4): t5: i32 = ADDI TargetFrameIndex:i32<1>, TargetConstant:i32<0>


Examining Available:
Height 8: SU(5): t2: i32,ch = CopyFromReg t0, Register:i32 %0

Height 6: SU(7): t4: i32,ch = CopyFromReg t0, Register:i32 %1


*** Scheduling [9]: SU(5): t2: i32,ch = CopyFromReg t0, Register:i32 %0


Examining Available:
Height 6: SU(7): t4: i32,ch = CopyFromReg t0, Register:i32 %1


*** Scheduling [10]: SU(7): t4: i32,ch = CopyFromReg t0, Register:i32 %1

*** Final schedule ***
SU(7): t4: i32,ch = CopyFromReg t0, Register:i32 %1

SU(5): t2: i32,ch = CopyFromReg t0, Register:i32 %0

SU(4): t5: i32 = ADDI TargetFrameIndex:i32<1>, TargetConstant:i32<0>

SU(3): t8: ch = STR<Mem:(store (s32) into %ir.a.addr)> t2, t5, t0

SU(6): t9: i32 = ADDI TargetFrameIndex:i32<2>, TargetConstant:i32<0>

SU(2): t10: ch = STR<Mem:(store (s32) into %ir.b.addr)> t4, t9, t8

SU(10): t11: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> t5, t10

SU(9): t12: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> t9, t10

SU(8): t25: i32 = CMP t11, t12

SU(1): t24: ch = BRNCHZ t25, BasicBlock:ch<if.else 0x6268cc119358>, t10

SU(0): t20: ch = BRNCH BasicBlock:ch<if.then 0x6268cc119238>, t24


Total amount of phi nodes to update: 0
Creating constant: t2: i32 = Constant<0>
Creating new node: t3: i32 = undef
Creating new node: t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32
Creating new node: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
Creating new node: t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>

Initial selection DAG: %bb.2 '_Z6branchii:if.else'
SelectionDAG has 9 nodes:
  t2: i32 = Constant<0>
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32
    t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
  t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>



Combining: t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>

Combining: t7: ch = BasicBlock<return 0x6268cc119478>

Combining: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32

Combining: t5: i32 = FrameIndex<0>

Combining: t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32

Combining: t3: i32 = undef

Combining: t1: i32 = FrameIndex<2>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.2 '_Z6branchii:if.else'
SelectionDAG has 8 nodes:
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32
    t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
  t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>



Legalizing node: t7: ch = BasicBlock<return 0x6268cc119478>
Analyzing result type: ch
Legal result type
Legally typed node: t7: ch = BasicBlock<return 0x6268cc119478>

Legalizing node: t5: i32 = FrameIndex<0>
Analyzing result type: i32
Legal result type
Legally typed node: t5: i32 = FrameIndex<0>

Legalizing node: t3: i32 = undef
Analyzing result type: i32
Legal result type
Legally typed node: t3: i32 = undef

Legalizing node: t1: i32 = FrameIndex<2>
Analyzing result type: i32
Legal result type
Legally typed node: t1: i32 = FrameIndex<2>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i32 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i32 = undef
Legal operand
Legally typed node: t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32

Legalizing node: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
Analyzing result type: ch
Legal result type
Analyzing operand: t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32
Legal operand
Analyzing operand: t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32
Legal operand
Analyzing operand: t5: i32 = FrameIndex<0>
Legal operand
Analyzing operand: t3: i32 = undef
Legal operand
Legally typed node: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32

Legalizing node: t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>
Analyzing result type: ch
Legal result type
Analyzing operand: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
Legal operand
Analyzing operand: t7: ch = BasicBlock<return 0x6268cc119478>
Legal operand
Legally typed node: t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>

Legalizing node: t65535: ch = handlenode t8
Analyzing result type: ch
Legal result type
Analyzing operand: t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>
Legal operand
Legally typed node: t65535: ch = handlenode t8

Type-legalized selection DAG: %bb.2 '_Z6branchii:if.else'
SelectionDAG has 8 nodes:
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32
    t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
  t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>



Legalizing: t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>
Legal node: nothing to do

Legalizing: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32
Legalizing non-extending load operation

Legalizing: t7: ch = BasicBlock<return 0x6268cc119478>
Legal node: nothing to do

Legalizing: t5: i32 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t3: i32 = undef
Legal node: nothing to do

Legalizing: t1: i32 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.2 '_Z6branchii:if.else'
SelectionDAG has 8 nodes:
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32
    t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
  t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>



Legalizing: t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>
Legal node: nothing to do

Combining: t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>

Legalizing: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32

Legalizing: t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32
Legalizing non-extending load operation

Combining: t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32

Legalizing: t7: ch = BasicBlock<return 0x6268cc119478>
Legal node: nothing to do

Combining: t7: ch = BasicBlock<return 0x6268cc119478>

Legalizing: t5: i32 = FrameIndex<0>
Legal node: nothing to do

Combining: t5: i32 = FrameIndex<0>

Legalizing: t3: i32 = undef
Legal node: nothing to do

Combining: t3: i32 = undef

Legalizing: t1: i32 = FrameIndex<2>
Legal node: nothing to do

Combining: t1: i32 = FrameIndex<2>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.2 '_Z6branchii:if.else'
SelectionDAG has 8 nodes:
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32
    t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
  t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>


Writing '/tmp/dag._Z6branchii-363cc7.dot'...  done. 
Trying 'xdg-open' program... Remember to erase graph file: /tmp/dag._Z6branchii-363cc7.dot
===== Instruction selection begins: %bb.2 'if.else'

ISEL: Starting selection on root node: t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>
ISEL: Starting pattern match
  Initial Opcode index to 331
  Morphed node: t8: ch = BRNCH BasicBlock:ch<return 0x6268cc119478>, t6
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
ISEL: Starting pattern match
  Initial Opcode index to 53
  Match failed at index 59
  Continuing at 77
  Morphed node: t6: ch = STR<Mem:(store (s32) into %ir.retval)> t4, FrameIndex:i32<0>, t4:1
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32
ISEL: Starting pattern match
  Initial Opcode index to 254
  Morphed node: t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> FrameIndex:i32<2>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t7: ch = BasicBlock<return 0x6268cc119478>

ISEL: Starting selection on root node: t5: i32 = FrameIndex<0>
ISEL: Starting pattern match
  Initial Opcode index to 347
Creating constant: t10: i32 = TargetConstant<0>
  Morphed node: t5: i32 = ADDI TargetFrameIndex:i32<0>, TargetConstant:i32<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t1: i32 = FrameIndex<2>
ISEL: Starting pattern match
  Initial Opcode index to 347
  Morphed node: t1: i32 = ADDI TargetFrameIndex:i32<2>, TargetConstant:i32<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:

Selected selection DAG: %bb.2 '_Z6branchii:if.else'
SelectionDAG has 10 nodes:
    t1: i32 = ADDI TargetFrameIndex:i32<2>, TargetConstant:i32<0>
    t0: ch,glue = EntryToken
  t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> t1, t0
      t5: i32 = ADDI TargetFrameIndex:i32<0>, TargetConstant:i32<0>
    t6: ch = STR<Mem:(store (s32) into %ir.retval)> t4, t5, t4:1
  t8: ch = BRNCH BasicBlock:ch<return 0x6268cc119478>, t6


********** List Scheduling %bb.2 'if.else' **********
SU(0): t8: ch = BRNCH BasicBlock:ch<return 0x6268cc119478>, t6

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t6: ch = STR<Mem:(store (s32) into %ir.retval)> t4, t5, t4:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(3): Data Latency=1
    SU(2): Data Latency=1
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t5: i32 = ADDI TargetFrameIndex:i32<0>, TargetConstant:i32<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1
SU(3): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> t1, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(1): Data Latency=1
    SU(1): Ord  Latency=1 Barrier
SU(4): t1: i32 = ADDI TargetFrameIndex:i32<2>, TargetConstant:i32<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(3): Data Latency=1

Examining Available:
Height 0: SU(0): t8: ch = BRNCH BasicBlock:ch<return 0x6268cc119478>, t6


*** Scheduling [0]: SU(0): t8: ch = BRNCH BasicBlock:ch<return 0x6268cc119478>, t6


Examining Available:
Height 1: SU(1): t6: ch = STR<Mem:(store (s32) into %ir.retval)> t4, t5, t4:1


*** Scheduling [1]: SU(1): t6: ch = STR<Mem:(store (s32) into %ir.retval)> t4, t5, t4:1


Examining Available:
Height 2: SU(2): t5: i32 = ADDI TargetFrameIndex:i32<0>, TargetConstant:i32<0>

Height 2: SU(3): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> t1, t0


*** Scheduling [2]: SU(2): t5: i32 = ADDI TargetFrameIndex:i32<0>, TargetConstant:i32<0>


Examining Available:
Height 2: SU(3): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> t1, t0


*** Scheduling [3]: SU(3): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> t1, t0


Examining Available:
Height 4: SU(4): t1: i32 = ADDI TargetFrameIndex:i32<2>, TargetConstant:i32<0>


*** Scheduling [4]: SU(4): t1: i32 = ADDI TargetFrameIndex:i32<2>, TargetConstant:i32<0>

*** Final schedule ***
SU(4): t1: i32 = ADDI TargetFrameIndex:i32<2>, TargetConstant:i32<0>

SU(3): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> t1, t0

SU(2): t5: i32 = ADDI TargetFrameIndex:i32<0>, TargetConstant:i32<0>

SU(1): t6: ch = STR<Mem:(store (s32) into %ir.retval)> t4, t5, t4:1

SU(0): t8: ch = BRNCH BasicBlock:ch<return 0x6268cc119478>, t6


Total amount of phi nodes to update: 0
Creating constant: t2: i32 = Constant<0>
Creating new node: t3: i32 = undef
Creating new node: t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32
Creating new node: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
Creating new node: t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>

Initial selection DAG: %bb.1 '_Z6branchii:if.then'
SelectionDAG has 9 nodes:
  t2: i32 = Constant<0>
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32
    t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
  t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>



Combining: t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>

Combining: t7: ch = BasicBlock<return 0x6268cc119478>

Combining: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32

Combining: t5: i32 = FrameIndex<0>

Combining: t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32

Combining: t3: i32 = undef

Combining: t1: i32 = FrameIndex<1>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.1 '_Z6branchii:if.then'
SelectionDAG has 8 nodes:
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32
    t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
  t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>



Legalizing node: t7: ch = BasicBlock<return 0x6268cc119478>
Analyzing result type: ch
Legal result type
Legally typed node: t7: ch = BasicBlock<return 0x6268cc119478>

Legalizing node: t5: i32 = FrameIndex<0>
Analyzing result type: i32
Legal result type
Legally typed node: t5: i32 = FrameIndex<0>

Legalizing node: t3: i32 = undef
Analyzing result type: i32
Legal result type
Legally typed node: t3: i32 = undef

Legalizing node: t1: i32 = FrameIndex<1>
Analyzing result type: i32
Legal result type
Legally typed node: t1: i32 = FrameIndex<1>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i32 = FrameIndex<1>
Legal operand
Analyzing operand: t3: i32 = undef
Legal operand
Legally typed node: t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32

Legalizing node: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
Analyzing result type: ch
Legal result type
Analyzing operand: t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32
Legal operand
Analyzing operand: t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32
Legal operand
Analyzing operand: t5: i32 = FrameIndex<0>
Legal operand
Analyzing operand: t3: i32 = undef
Legal operand
Legally typed node: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32

Legalizing node: t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>
Analyzing result type: ch
Legal result type
Analyzing operand: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
Legal operand
Analyzing operand: t7: ch = BasicBlock<return 0x6268cc119478>
Legal operand
Legally typed node: t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>

Legalizing node: t65535: ch = handlenode t8
Analyzing result type: ch
Legal result type
Analyzing operand: t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>
Legal operand
Legally typed node: t65535: ch = handlenode t8

Type-legalized selection DAG: %bb.1 '_Z6branchii:if.then'
SelectionDAG has 8 nodes:
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32
    t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
  t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>



Legalizing: t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>
Legal node: nothing to do

Legalizing: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32
Legalizing non-extending load operation

Legalizing: t7: ch = BasicBlock<return 0x6268cc119478>
Legal node: nothing to do

Legalizing: t5: i32 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t3: i32 = undef
Legal node: nothing to do

Legalizing: t1: i32 = FrameIndex<1>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.1 '_Z6branchii:if.then'
SelectionDAG has 8 nodes:
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32
    t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
  t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>



Legalizing: t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>
Legal node: nothing to do

Combining: t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>

Legalizing: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32

Legalizing: t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32
Legalizing non-extending load operation

Combining: t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32

Legalizing: t7: ch = BasicBlock<return 0x6268cc119478>
Legal node: nothing to do

Combining: t7: ch = BasicBlock<return 0x6268cc119478>

Legalizing: t5: i32 = FrameIndex<0>
Legal node: nothing to do

Combining: t5: i32 = FrameIndex<0>

Legalizing: t3: i32 = undef
Legal node: nothing to do

Combining: t3: i32 = undef

Legalizing: t1: i32 = FrameIndex<1>
Legal node: nothing to do

Combining: t1: i32 = FrameIndex<1>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.1 '_Z6branchii:if.then'
SelectionDAG has 8 nodes:
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32
    t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
  t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>


Writing '/tmp/dag._Z6branchii-9e2a58.dot'...  done. 
Trying 'xdg-open' program... Remember to erase graph file: /tmp/dag._Z6branchii-9e2a58.dot
===== Instruction selection begins: %bb.1 'if.then'

ISEL: Starting selection on root node: t8: ch = br t6, BasicBlock:ch<return 0x6268cc119478>
ISEL: Starting pattern match
  Initial Opcode index to 331
  Morphed node: t8: ch = BRNCH BasicBlock:ch<return 0x6268cc119478>, t6
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
ISEL: Starting pattern match
  Initial Opcode index to 53
  Match failed at index 59
  Continuing at 77
  Morphed node: t6: ch = STR<Mem:(store (s32) into %ir.retval)> t4, FrameIndex:i32<0>, t4:1
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32
ISEL: Starting pattern match
  Initial Opcode index to 254
  Morphed node: t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> FrameIndex:i32<1>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t7: ch = BasicBlock<return 0x6268cc119478>

ISEL: Starting selection on root node: t5: i32 = FrameIndex<0>
ISEL: Starting pattern match
  Initial Opcode index to 347
Creating constant: t10: i32 = TargetConstant<0>
  Morphed node: t5: i32 = ADDI TargetFrameIndex:i32<0>, TargetConstant:i32<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t1: i32 = FrameIndex<1>
ISEL: Starting pattern match
  Initial Opcode index to 347
  Morphed node: t1: i32 = ADDI TargetFrameIndex:i32<1>, TargetConstant:i32<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:

Selected selection DAG: %bb.1 '_Z6branchii:if.then'
SelectionDAG has 10 nodes:
    t1: i32 = ADDI TargetFrameIndex:i32<1>, TargetConstant:i32<0>
    t0: ch,glue = EntryToken
  t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> t1, t0
      t5: i32 = ADDI TargetFrameIndex:i32<0>, TargetConstant:i32<0>
    t6: ch = STR<Mem:(store (s32) into %ir.retval)> t4, t5, t4:1
  t8: ch = BRNCH BasicBlock:ch<return 0x6268cc119478>, t6


********** List Scheduling %bb.1 'if.then' **********
SU(0): t8: ch = BRNCH BasicBlock:ch<return 0x6268cc119478>, t6

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t6: ch = STR<Mem:(store (s32) into %ir.retval)> t4, t5, t4:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(3): Data Latency=1
    SU(2): Data Latency=1
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t5: i32 = ADDI TargetFrameIndex:i32<0>, TargetConstant:i32<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1
SU(3): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> t1, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(1): Data Latency=1
    SU(1): Ord  Latency=1 Barrier
SU(4): t1: i32 = ADDI TargetFrameIndex:i32<1>, TargetConstant:i32<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(3): Data Latency=1

Examining Available:
Height 0: SU(0): t8: ch = BRNCH BasicBlock:ch<return 0x6268cc119478>, t6


*** Scheduling [0]: SU(0): t8: ch = BRNCH BasicBlock:ch<return 0x6268cc119478>, t6


Examining Available:
Height 1: SU(1): t6: ch = STR<Mem:(store (s32) into %ir.retval)> t4, t5, t4:1


*** Scheduling [1]: SU(1): t6: ch = STR<Mem:(store (s32) into %ir.retval)> t4, t5, t4:1


Examining Available:
Height 2: SU(2): t5: i32 = ADDI TargetFrameIndex:i32<0>, TargetConstant:i32<0>

Height 2: SU(3): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> t1, t0


*** Scheduling [2]: SU(2): t5: i32 = ADDI TargetFrameIndex:i32<0>, TargetConstant:i32<0>


Examining Available:
Height 2: SU(3): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> t1, t0


*** Scheduling [3]: SU(3): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> t1, t0


Examining Available:
Height 4: SU(4): t1: i32 = ADDI TargetFrameIndex:i32<1>, TargetConstant:i32<0>


*** Scheduling [4]: SU(4): t1: i32 = ADDI TargetFrameIndex:i32<1>, TargetConstant:i32<0>

*** Final schedule ***
SU(4): t1: i32 = ADDI TargetFrameIndex:i32<1>, TargetConstant:i32<0>

SU(3): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> t1, t0

SU(2): t5: i32 = ADDI TargetFrameIndex:i32<0>, TargetConstant:i32<0>

SU(1): t6: ch = STR<Mem:(store (s32) into %ir.retval)> t4, t5, t4:1

SU(0): t8: ch = BRNCH BasicBlock:ch<return 0x6268cc119478>, t6


Total amount of phi nodes to update: 0
Creating constant: t2: i32 = Constant<0>
Creating new node: t3: i32 = undef
Creating new node: t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32
Creating new node: t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4
Creating new node: t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1

Initial selection DAG: %bb.3 '_Z6branchii:return'
SelectionDAG has 8 nodes:
  t0: ch,glue = EntryToken
  t2: i32 = Constant<0>
    t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32
  t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4
  t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1



Combining: t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1

Combining: t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4

Combining: t5: i32 = Register $r0

Combining: t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32

Combining: t3: i32 = undef

Combining: t1: i32 = FrameIndex<0>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.3 '_Z6branchii:return'
SelectionDAG has 7 nodes:
  t0: ch,glue = EntryToken
    t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32
  t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4
  t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1



Legalizing node: t5: i32 = Register $r0
Ignoring node results
Legally typed node: t5: i32 = Register $r0

Legalizing node: t3: i32 = undef
Analyzing result type: i32
Legal result type
Legally typed node: t3: i32 = undef

Legalizing node: t1: i32 = FrameIndex<0>
Analyzing result type: i32
Legal result type
Legally typed node: t1: i32 = FrameIndex<0>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i32 = FrameIndex<0>
Legal operand
Analyzing operand: t3: i32 = undef
Legal operand
Legally typed node: t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32

Legalizing node: t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32
Legal operand
Legally typed node: t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4

Legalizing node: t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1
Analyzing result type: ch
Legal result type
Analyzing operand: t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4
Legal operand
Analyzing operand: t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4
Legal operand
Legally typed node: t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1

Legalizing node: t65535: ch = handlenode t7
Analyzing result type: ch
Legal result type
Analyzing operand: t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1
Legal operand
Legally typed node: t65535: ch = handlenode t7

Type-legalized selection DAG: %bb.3 '_Z6branchii:return'
SelectionDAG has 7 nodes:
  t0: ch,glue = EntryToken
    t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32
  t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4
  t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1



Legalizing: t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1
Legal node: nothing to do

Legalizing: t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4
Legal node: nothing to do

Legalizing: t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32
Legalizing non-extending load operation

Legalizing: t5: i32 = Register $r0

Legalizing: t3: i32 = undef
Legal node: nothing to do

Legalizing: t1: i32 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.3 '_Z6branchii:return'
SelectionDAG has 7 nodes:
  t0: ch,glue = EntryToken
    t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32
  t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4
  t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1



Legalizing: t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1
Legal node: nothing to do

Combining: t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1

Legalizing: t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4
Legal node: nothing to do

Combining: t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4

Legalizing: t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32
Legalizing non-extending load operation

Combining: t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32

Legalizing: t5: i32 = Register $r0

Combining: t5: i32 = Register $r0

Legalizing: t3: i32 = undef
Legal node: nothing to do

Combining: t3: i32 = undef

Legalizing: t1: i32 = FrameIndex<0>
Legal node: nothing to do

Combining: t1: i32 = FrameIndex<0>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.3 '_Z6branchii:return'
SelectionDAG has 7 nodes:
  t0: ch,glue = EntryToken
    t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32
  t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4
  t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1


Writing '/tmp/dag._Z6branchii-55f2f7.dot'...  done. 
Trying 'xdg-open' program... Remember to erase graph file: /tmp/dag._Z6branchii-55f2f7.dot
===== Instruction selection begins: %bb.3 'return'

ISEL: Starting selection on root node: t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1
ISEL: Starting pattern match
  Initial Opcode index to 272
  Morphed node: t7: ch = PseudoRET Register:i32 $r0, t6, t6:1
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4

ISEL: Starting selection on root node: t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32
ISEL: Starting pattern match
  Initial Opcode index to 254
  Morphed node: t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.retval)> FrameIndex:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t5: i32 = Register $r0

ISEL: Starting selection on root node: t1: i32 = FrameIndex<0>
ISEL: Starting pattern match
  Initial Opcode index to 347
Creating constant: t9: i32 = TargetConstant<0>
  Morphed node: t1: i32 = ADDI TargetFrameIndex:i32<0>, TargetConstant:i32<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:

Selected selection DAG: %bb.3 '_Z6branchii:return'
SelectionDAG has 8 nodes:
  t0: ch,glue = EntryToken
      t1: i32 = ADDI TargetFrameIndex:i32<0>, TargetConstant:i32<0>
    t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.retval)> t1, t0
  t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4
  t7: ch = PseudoRET Register:i32 $r0, t6, t6:1


********** List Scheduling %bb.3 'return' **********
SU(0): t7: ch = PseudoRET Register:i32 $r0, t6, t6:1

    t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1
SU(1): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.retval)> t1, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Data Latency=1
SU(2): t1: i32 = ADDI TargetFrameIndex:i32<0>, TargetConstant:i32<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t7: ch = PseudoRET Register:i32 $r0, t6, t6:1

    t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4


*** Scheduling [0]: SU(0): t7: ch = PseudoRET Register:i32 $r0, t6, t6:1

    t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4


Examining Available:
Height 1: SU(1): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.retval)> t1, t0


*** Scheduling [1]: SU(1): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.retval)> t1, t0


Examining Available:
Height 2: SU(2): t1: i32 = ADDI TargetFrameIndex:i32<0>, TargetConstant:i32<0>


*** Scheduling [2]: SU(2): t1: i32 = ADDI TargetFrameIndex:i32<0>, TargetConstant:i32<0>

*** Final schedule ***
SU(2): t1: i32 = ADDI TargetFrameIndex:i32<0>, TargetConstant:i32<0>

SU(1): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.retval)> t1, t0

SU(0): t7: ch = PseudoRET Register:i32 $r0, t6, t6:1

    t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function _Z6branchii: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP]
  fi#1: size=4, align=4, at location [SP]
  fi#2: size=4, align=4, at location [SP]
Function Live Ins: $r0 in %0, $r1 in %1

bb.0.entry:
  successors: %bb.1, %bb.2
  liveins: $r0, $r1
  %1:gpr = COPY $r1
  %0:gpr = COPY $r0
  %2:gpr = ADDI %stack.1.a.addr, 0
  STR %0:gpr, %2:gpr :: (store (s32) into %ir.a.addr)
  %3:gpr = ADDI %stack.2.b.addr, 0
  STR %1:gpr, %3:gpr :: (store (s32) into %ir.b.addr)
  %4:gpr = LDR %2:gpr :: (dereferenceable load (s32) from %ir.a.addr)
  %5:gpr = LDR %3:gpr :: (dereferenceable load (s32) from %ir.b.addr)
  %6:gpr = CMP killed %4:gpr, killed %5:gpr
  BRNCHZ killed %6:gpr, %bb.2
  BRNCH %bb.1

bb.1.if.then:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %10:gpr = ADDI %stack.1.a.addr, 0
  %11:gpr = LDR killed %10:gpr :: (dereferenceable load (s32) from %ir.a.addr)
  %12:gpr = ADDI %stack.0.retval, 0
  STR killed %11:gpr, killed %12:gpr :: (store (s32) into %ir.retval)
  BRNCH %bb.3

bb.2.if.else:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %7:gpr = ADDI %stack.2.b.addr, 0
  %8:gpr = LDR killed %7:gpr :: (dereferenceable load (s32) from %ir.b.addr)
  %9:gpr = ADDI %stack.0.retval, 0
  STR killed %8:gpr, killed %9:gpr :: (store (s32) into %ir.retval)
  BRNCH %bb.3

bb.3.return:
; predecessors: %bb.2, %bb.1

  %13:gpr = ADDI %stack.0.retval, 0
  %14:gpr = LDR killed %13:gpr :: (dereferenceable load (s32) from %ir.retval)
  $r0 = COPY %14:gpr
  PseudoRET implicit $r0

# End machine code for function _Z6branchii.

Skipping pass 'Two-Address instruction pass' on function _Z6branchii
********** REWRITING TWO-ADDR INSTRS **********
********** Function: _Z6branchii
********** FAST REGISTER ALLOCATION **********
********** Function: _Z6branchii

Allocating bb.0.entry:
  successors: %bb.1, %bb.2
  liveins: $r0, $r1
  %1:gpr = COPY $r1
  %0:gpr = COPY $r0
  %2:gpr = ADDI %stack.1.a.addr, 0
  STR %0:gpr, %2:gpr :: (store (s32) into %ir.a.addr)
  %3:gpr = ADDI %stack.2.b.addr, 0
  STR %1:gpr, %3:gpr :: (store (s32) into %ir.b.addr)
  %4:gpr = LDR %2:gpr :: (dereferenceable load (s32) from %ir.a.addr)
  %5:gpr = LDR %3:gpr :: (dereferenceable load (s32) from %ir.b.addr)
  %6:gpr = CMP killed %4:gpr, killed %5:gpr
  BRNCHZ killed %6:gpr, %bb.2
  BRNCH %bb.1

>> BRNCH %bb.1
Regs:
<< BRNCH %bb.1

>> BRNCHZ killed %6:gpr, %bb.2
Regs:
Search register for %6 in class GPR with hint $noreg
AllocationOrder(GPR) = [ $r0 $r1 $r2 $r3 $r4 $r5 $r6 $r7 $r10 $r8 $r9 ]
	Register: $r0 Cost: 0 BestCost: 4294967295
Assigning %6 to $r0
<< BRNCHZ killed $r0, %bb.2

>> %6:gpr = CMP killed %4:gpr, killed %5:gpr
Regs: R0=%6
In def of %6 use existing assignment to $r0
Freeing $r0: %6
Search register for %4 in class GPR with hint $noreg
	Register: $r0 Cost: 0 BestCost: 4294967295
Assigning %4 to $r0
Search register for %5 in class GPR with hint $noreg
	Register: $r0 already used in instr.
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %5 to $r1
<< $r0 = CMP killed $r0, killed $r1

>> %5:gpr = LDR %3:gpr :: (dereferenceable load (s32) from %ir.b.addr)
Regs: R0=%4 R1=%5
In def of %5 use existing assignment to $r1
Freeing $r1: %5
Search register for %3 in class GPR with hint $noreg
	Register: $r0 Cost: 100 BestCost: 4294967295
	Register: $r1 Cost: 0 BestCost: 100
Assigning %3 to $r1
<< $r1 = LDR killed $r1 :: (dereferenceable load (s32) from %ir.b.addr)

>> %4:gpr = LDR %2:gpr :: (dereferenceable load (s32) from %ir.a.addr)
Regs: R0=%4 R1=%3
In def of %4 use existing assignment to $r0
Freeing $r0: %4
Search register for %2 in class GPR with hint $noreg
	Register: $r0 Cost: 0 BestCost: 4294967295
Assigning %2 to $r0
<< $r0 = LDR killed $r0 :: (dereferenceable load (s32) from %ir.a.addr)

>> STR %1:gpr, %3:gpr :: (store (s32) into %ir.b.addr)
Regs: R0=%2 R1=%3
Search register for %1 in class GPR with hint $noreg
	Preferred Register 1: $r1 occupied
	Register: $r0 Cost: 100 BestCost: 4294967295
	Register: $r1 Cost: 100 BestCost: 100
	Register: $r2 Cost: 0 BestCost: 80
Assigning %1 to $r2
<< STR killed $r2, $r1 :: (store (s32) into %ir.b.addr)

>> %3:gpr = ADDI %stack.2.b.addr, 0
Regs: R0=%2 R1=%3 R2=%1
In def of %3 use existing assignment to $r1
Freeing $r1: %3
<< $r1 = ADDI %stack.2.b.addr, 0

>> STR %0:gpr, %2:gpr :: (store (s32) into %ir.a.addr)
Regs: R0=%2 R2=%1
Search register for %0 in class GPR with hint $noreg
	Preferred Register 1: $r0 occupied
	Register: $r0 Cost: 100 BestCost: 4294967295
	Register: $r1 Cost: 0 BestCost: 80
Assigning %0 to $r1
<< STR killed $r1, $r0 :: (store (s32) into %ir.a.addr)

>> %2:gpr = ADDI %stack.1.a.addr, 0
Regs: R0=%2 R1=%0 R2=%1
In def of %2 use existing assignment to $r0
Freeing $r0: %2
<< $r0 = ADDI %stack.1.a.addr, 0

>> %0:gpr = COPY $r0
Regs: R1=%0 R2=%1
In def of %0 use existing assignment to $r1
Freeing $r1: %0
<< $r1 = COPY killed $r0

>> %1:gpr = COPY $r1
Regs: R0[P] R2=%1
In def of %1 use existing assignment to $r2
Freeing $r2: %1
<< $r2 = COPY killed $r1
Begin Regs: R0[P] R1[P]
Loading live registers at begin of block.
bb.0.entry:
  successors: %bb.1, %bb.2
  liveins: $r0, $r1
  $r2 = COPY killed $r1
  $r1 = COPY killed $r0
  $r0 = ADDI %stack.1.a.addr, 0
  STR killed $r1, $r0 :: (store (s32) into %ir.a.addr)
  $r1 = ADDI %stack.2.b.addr, 0
  STR killed $r2, $r1 :: (store (s32) into %ir.b.addr)
  $r0 = LDR killed $r0 :: (dereferenceable load (s32) from %ir.a.addr)
  $r1 = LDR killed $r1 :: (dereferenceable load (s32) from %ir.b.addr)
  $r0 = CMP killed $r0, killed $r1
  BRNCHZ killed $r0, %bb.2
  BRNCH %bb.1

Allocating bb.1.if.then:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %10:gpr = ADDI %stack.1.a.addr, 0
  %11:gpr = LDR killed %10:gpr :: (dereferenceable load (s32) from %ir.a.addr)
  %12:gpr = ADDI %stack.0.retval, 0
  STR killed %11:gpr, killed %12:gpr :: (store (s32) into %ir.retval)
  BRNCH %bb.3

>> BRNCH %bb.3
Regs:
<< BRNCH %bb.3

>> STR killed %11:gpr, killed %12:gpr :: (store (s32) into %ir.retval)
Regs:
Search register for %11 in class GPR with hint $noreg
	Register: $r0 Cost: 0 BestCost: 4294967295
Assigning %11 to $r0
Search register for %12 in class GPR with hint $noreg
	Register: $r0 already used in instr.
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %12 to $r1
<< STR killed $r0, killed $r1 :: (store (s32) into %ir.retval)

>> %12:gpr = ADDI %stack.0.retval, 0
Regs: R0=%11 R1=%12
In def of %12 use existing assignment to $r1
Freeing $r1: %12
<< $r1 = ADDI %stack.0.retval, 0

>> %11:gpr = LDR killed %10:gpr :: (dereferenceable load (s32) from %ir.a.addr)
Regs: R0=%11
In def of %11 use existing assignment to $r0
Freeing $r0: %11
Search register for %10 in class GPR with hint $noreg
	Register: $r0 Cost: 0 BestCost: 4294967295
Assigning %10 to $r0
<< $r0 = LDR killed $r0 :: (dereferenceable load (s32) from %ir.a.addr)

>> %10:gpr = ADDI %stack.1.a.addr, 0
Regs: R0=%10
In def of %10 use existing assignment to $r0
Freeing $r0: %10
<< $r0 = ADDI %stack.1.a.addr, 0
Begin Regs:
Loading live registers at begin of block.
bb.1.if.then:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  $r0 = ADDI %stack.1.a.addr, 0
  $r0 = LDR killed $r0 :: (dereferenceable load (s32) from %ir.a.addr)
  $r1 = ADDI %stack.0.retval, 0
  STR killed $r0, killed $r1 :: (store (s32) into %ir.retval)
  BRNCH %bb.3

Allocating bb.2.if.else:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %7:gpr = ADDI %stack.2.b.addr, 0
  %8:gpr = LDR killed %7:gpr :: (dereferenceable load (s32) from %ir.b.addr)
  %9:gpr = ADDI %stack.0.retval, 0
  STR killed %8:gpr, killed %9:gpr :: (store (s32) into %ir.retval)
  BRNCH %bb.3

>> BRNCH %bb.3
Regs:
<< BRNCH %bb.3

>> STR killed %8:gpr, killed %9:gpr :: (store (s32) into %ir.retval)
Regs:
Search register for %8 in class GPR with hint $noreg
	Register: $r0 Cost: 0 BestCost: 4294967295
Assigning %8 to $r0
Search register for %9 in class GPR with hint $noreg
	Register: $r0 already used in instr.
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %9 to $r1
<< STR killed $r0, killed $r1 :: (store (s32) into %ir.retval)

>> %9:gpr = ADDI %stack.0.retval, 0
Regs: R0=%8 R1=%9
In def of %9 use existing assignment to $r1
Freeing $r1: %9
<< $r1 = ADDI %stack.0.retval, 0

>> %8:gpr = LDR killed %7:gpr :: (dereferenceable load (s32) from %ir.b.addr)
Regs: R0=%8
In def of %8 use existing assignment to $r0
Freeing $r0: %8
Search register for %7 in class GPR with hint $noreg
	Register: $r0 Cost: 0 BestCost: 4294967295
Assigning %7 to $r0
<< $r0 = LDR killed $r0 :: (dereferenceable load (s32) from %ir.b.addr)

>> %7:gpr = ADDI %stack.2.b.addr, 0
Regs: R0=%7
In def of %7 use existing assignment to $r0
Freeing $r0: %7
<< $r0 = ADDI %stack.2.b.addr, 0
Begin Regs:
Loading live registers at begin of block.
bb.2.if.else:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  $r0 = ADDI %stack.2.b.addr, 0
  $r0 = LDR killed $r0 :: (dereferenceable load (s32) from %ir.b.addr)
  $r1 = ADDI %stack.0.retval, 0
  STR killed $r0, killed $r1 :: (store (s32) into %ir.retval)
  BRNCH %bb.3

Allocating bb.3.return:
; predecessors: %bb.2, %bb.1

  %13:gpr = ADDI %stack.0.retval, 0
  %14:gpr = LDR killed %13:gpr :: (dereferenceable load (s32) from %ir.retval)
  $r0 = COPY %14:gpr
  PseudoRET implicit $r0

>> PseudoRET implicit $r0
Regs:
<< PseudoRET implicit killed $r0

>> $r0 = COPY %14:gpr
Regs: R0[P]
Freeing $r0:
Search register for %14 in class GPR with hint $r0
	Preferred Register 1: $r0
Assigning %14 to $r0
<< $r0 = COPY killed $r0
Mark identity copy for removal

>> %14:gpr = LDR killed %13:gpr :: (dereferenceable load (s32) from %ir.retval)
Regs: R0=%14
In def of %14 use existing assignment to $r0
Freeing $r0: %14
Search register for %13 in class GPR with hint $noreg
	Register: $r0 Cost: 0 BestCost: 4294967295
Assigning %13 to $r0
<< $r0 = LDR killed $r0 :: (dereferenceable load (s32) from %ir.retval)

>> %13:gpr = ADDI %stack.0.retval, 0
Regs: R0=%13
In def of %13 use existing assignment to $r0
Freeing $r0: %13
<< $r0 = ADDI %stack.0.retval, 0
Begin Regs:
Loading live registers at begin of block.
bb.3.return:
; predecessors: %bb.2, %bb.1

  $r0 = ADDI %stack.0.retval, 0
  $r0 = LDR killed $r0 :: (dereferenceable load (s32) from %ir.retval)
  PseudoRET implicit killed $r0
Skipping pass 'Fixup Statepoint Caller Saved' on function _Z6branchii
alloc FI(0) at SP[-4]
alloc FI(1) at SP[-8]
alloc FI(2) at SP[-12]
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: _Z6branchii

Debug Range Extension: _Z6branchii
