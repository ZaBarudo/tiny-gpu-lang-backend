Args: llc -march=tinygpu -O0 index6.ll -debug -view-isel-dags -o index.S 

Features:
CPU:generic
TuneCPU:generic

[SafeStack] Function: _Z6branchii
[SafeStack]     safestack is not requested for this function
Skipping pass 'CPU0 DAG->DAG Pattern Instruction Selection' on function _Z6branchii
	FastISel is enabled



=== _Z6branchii
Enabling fast-isel
Found argument copy elision candidate:   %a.addr = alloca i32, align 4
Found argument copy elision candidate:   %b.addr = alloca i32, align 4
Creating new node: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Creating new node: t4: i32,ch = CopyFromReg t0, Register:i32 %1
Creating constant: t6: i32 = Constant<0>
Creating new node: t7: i32 = undef
Creating new node: t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32
Creating new node: t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
Creating new node: t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32
Creating new node: t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32
Creating new node: t14: i1 = setcc t11, t12, setne:ch
Creating constant: t15: i1 = Constant<-1>
Creating new node: t16: i1 = xor t14, Constant:i1<-1>
Creating new node: t18: ch = brcond t10, t16, BasicBlock:ch<if.else 0x5d8e2caa11b8>
Creating new node: t20: ch = br t18, BasicBlock:ch<if.then 0x5d8e2caa1098>

Initial selection DAG: %bb.0 '_Z6branchii:entry'
SelectionDAG has 21 nodes:
  t0: ch,glue = EntryToken
  t6: i32 = Constant<0>
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32
    t4: i32,ch = CopyFromReg t0, Register:i32 %1
  t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
          t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32
          t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32
        t14: i1 = setcc t11, t12, setne:ch
      t16: i1 = xor t14, Constant:i1<-1>
    t18: ch = brcond t10, t16, BasicBlock:ch<if.else 0x5d8e2caa11b8>
  t20: ch = br t18, BasicBlock:ch<if.then 0x5d8e2caa1098>



Combining: t20: ch = br t18, BasicBlock:ch<if.then 0x5d8e2caa1098>

Combining: t19: ch = BasicBlock<if.then 0x5d8e2caa1098>

Combining: t18: ch = brcond t10, t16, BasicBlock:ch<if.else 0x5d8e2caa11b8>
Creating new node: t22: i1 = setcc t11, t12, seteq:ch
Creating new node: t23: ch = brcond t10, t22, BasicBlock:ch<if.else 0x5d8e2caa11b8>
 ... into: t23: ch = brcond t10, t22, BasicBlock:ch<if.else 0x5d8e2caa11b8>

Combining: t23: ch = brcond t10, t22, BasicBlock:ch<if.else 0x5d8e2caa11b8>
Creating new node: t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x5d8e2caa11b8>
 ... into: t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x5d8e2caa11b8>

Combining: t21: ch = seteq

Combining: t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x5d8e2caa11b8>

Combining: t20: ch = br t24, BasicBlock:ch<if.then 0x5d8e2caa1098>

Combining: t17: ch = BasicBlock<if.else 0x5d8e2caa11b8>

Combining: t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32

Combining: t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32

Combining: t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32

Combining: t9: i32 = FrameIndex<2>

Combining: t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32

Combining: t7: i32 = undef

Combining: t5: i32 = FrameIndex<1>

Combining: t4: i32,ch = CopyFromReg t0, Register:i32 %1

Combining: t3: i32 = Register %1

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %0

Combining: t1: i32 = Register %0

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.0 '_Z6branchii:entry'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32
    t4: i32,ch = CopyFromReg t0, Register:i32 %1
  t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
      t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32
      t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32
    t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x5d8e2caa11b8>
  t20: ch = br t24, BasicBlock:ch<if.then 0x5d8e2caa1098>



Legalizing node: t21: ch = seteq
Analyzing result type: ch
Legal result type
Legally typed node: t21: ch = seteq

Legalizing node: t19: ch = BasicBlock<if.then 0x5d8e2caa1098>
Analyzing result type: ch
Legal result type
Legally typed node: t19: ch = BasicBlock<if.then 0x5d8e2caa1098>

Legalizing node: t17: ch = BasicBlock<if.else 0x5d8e2caa11b8>
Analyzing result type: ch
Legal result type
Legally typed node: t17: ch = BasicBlock<if.else 0x5d8e2caa11b8>

Legalizing node: t9: i32 = FrameIndex<2>
Analyzing result type: i32
Legal result type
Legally typed node: t9: i32 = FrameIndex<2>

Legalizing node: t7: i32 = undef
Analyzing result type: i32
Legal result type
Legally typed node: t7: i32 = undef

Legalizing node: t5: i32 = FrameIndex<1>
Analyzing result type: i32
Legal result type
Legally typed node: t5: i32 = FrameIndex<1>

Legalizing node: t3: i32 = Register %1
Ignoring node results
Legally typed node: t3: i32 = Register %1

Legalizing node: t1: i32 = Register %0
Ignoring node results
Legally typed node: t1: i32 = Register %0

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i32,ch = CopyFromReg t0, Register:i32 %0

Legalizing node: t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Legal operand
Analyzing operand: t5: i32 = FrameIndex<1>
Legal operand
Analyzing operand: t7: i32 = undef
Legal operand
Legally typed node: t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32

Legalizing node: t4: i32,ch = CopyFromReg t0, Register:i32 %1
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t4: i32,ch = CopyFromReg t0, Register:i32 %1

Legalizing node: t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
Analyzing result type: ch
Legal result type
Analyzing operand: t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32
Legal operand
Analyzing operand: t4: i32,ch = CopyFromReg t0, Register:i32 %1
Legal operand
Analyzing operand: t9: i32 = FrameIndex<2>
Legal operand
Analyzing operand: t7: i32 = undef
Legal operand
Legally typed node: t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32

Legalizing node: t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
Legal operand
Analyzing operand: t5: i32 = FrameIndex<1>
Legal operand
Analyzing operand: t7: i32 = undef
Legal operand
Legally typed node: t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32

Legalizing node: t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
Legal operand
Analyzing operand: t9: i32 = FrameIndex<2>
Legal operand
Analyzing operand: t7: i32 = undef
Legal operand
Legally typed node: t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32

Legalizing node: t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x5d8e2caa11b8>
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
Legal operand
Analyzing operand: t21: ch = seteq
Legal operand
Analyzing operand: t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32
Legal operand
Analyzing operand: t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32
Legal operand
Analyzing operand: t17: ch = BasicBlock<if.else 0x5d8e2caa11b8>
Legal operand
Legally typed node: t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x5d8e2caa11b8>

Legalizing node: t20: ch = br t24, BasicBlock:ch<if.then 0x5d8e2caa1098>
Analyzing result type: ch
Legal result type
Analyzing operand: t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x5d8e2caa11b8>
Legal operand
Analyzing operand: t19: ch = BasicBlock<if.then 0x5d8e2caa1098>
Legal operand
Legally typed node: t20: ch = br t24, BasicBlock:ch<if.then 0x5d8e2caa1098>

Legalizing node: t65535: ch = handlenode t20
Analyzing result type: ch
Legal result type
Analyzing operand: t20: ch = br t24, BasicBlock:ch<if.then 0x5d8e2caa1098>
Legal operand
Legally typed node: t65535: ch = handlenode t20

Type-legalized selection DAG: %bb.0 '_Z6branchii:entry'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32
    t4: i32,ch = CopyFromReg t0, Register:i32 %1
  t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
      t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32
      t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32
    t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x5d8e2caa11b8>
  t20: ch = br t24, BasicBlock:ch<if.then 0x5d8e2caa1098>



Legalizing: t20: ch = br t24, BasicBlock:ch<if.then 0x5d8e2caa1098>
Legal node: nothing to do

Legalizing: t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x5d8e2caa11b8>
Legal node: nothing to do

Legalizing: t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32
Legalizing non-extending load operation

Legalizing: t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32
Legalizing non-extending load operation

Legalizing: t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t4: i32,ch = CopyFromReg t0, Register:i32 %1
Legal node: nothing to do

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Legal node: nothing to do

Legalizing: t21: ch = seteq
Legal node: nothing to do

Legalizing: t19: ch = BasicBlock<if.then 0x5d8e2caa1098>
Legal node: nothing to do

Legalizing: t17: ch = BasicBlock<if.else 0x5d8e2caa11b8>
Legal node: nothing to do

Legalizing: t9: i32 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t7: i32 = undef
Legal node: nothing to do

Legalizing: t5: i32 = FrameIndex<1>
Legal node: nothing to do

Legalizing: t3: i32 = Register %1

Legalizing: t1: i32 = Register %0

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.0 '_Z6branchii:entry'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32
    t4: i32,ch = CopyFromReg t0, Register:i32 %1
  t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
      t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32
      t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32
    t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x5d8e2caa11b8>
  t20: ch = br t24, BasicBlock:ch<if.then 0x5d8e2caa1098>



Legalizing: t20: ch = br t24, BasicBlock:ch<if.then 0x5d8e2caa1098>
Legal node: nothing to do

Combining: t20: ch = br t24, BasicBlock:ch<if.then 0x5d8e2caa1098>

Legalizing: t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x5d8e2caa11b8>
Legal node: nothing to do

Combining: t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x5d8e2caa11b8>

Legalizing: t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32
Legalizing non-extending load operation

Combining: t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32

Legalizing: t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32
Legalizing non-extending load operation

Combining: t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32

Legalizing: t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32

Legalizing: t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32

Legalizing: t4: i32,ch = CopyFromReg t0, Register:i32 %1
Legal node: nothing to do

Combining: t4: i32,ch = CopyFromReg t0, Register:i32 %1

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Legal node: nothing to do

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %0

Legalizing: t21: ch = seteq
Legal node: nothing to do

Combining: t21: ch = seteq

Legalizing: t19: ch = BasicBlock<if.then 0x5d8e2caa1098>
Legal node: nothing to do

Combining: t19: ch = BasicBlock<if.then 0x5d8e2caa1098>

Legalizing: t17: ch = BasicBlock<if.else 0x5d8e2caa11b8>
Legal node: nothing to do

Combining: t17: ch = BasicBlock<if.else 0x5d8e2caa11b8>

Legalizing: t9: i32 = FrameIndex<2>
Legal node: nothing to do

Combining: t9: i32 = FrameIndex<2>

Legalizing: t7: i32 = undef
Legal node: nothing to do

Combining: t7: i32 = undef

Legalizing: t5: i32 = FrameIndex<1>
Legal node: nothing to do

Combining: t5: i32 = FrameIndex<1>

Legalizing: t3: i32 = Register %1

Combining: t3: i32 = Register %1

Legalizing: t1: i32 = Register %0

Combining: t1: i32 = Register %0

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.0 '_Z6branchii:entry'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32
    t4: i32,ch = CopyFromReg t0, Register:i32 %1
  t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
      t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32
      t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32
    t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x5d8e2caa11b8>
  t20: ch = br t24, BasicBlock:ch<if.then 0x5d8e2caa1098>


Writing '/tmp/dag._Z6branchii-2d993f.dot'...  done. 
Trying 'xdg-open' program... Remember to erase graph file: /tmp/dag._Z6branchii-2d993f.dot
===== Instruction selection begins: %bb.0 'entry'

ISEL: Starting selection on root node: t20: ch = br t24, BasicBlock:ch<if.then 0x5d8e2caa1098>
ISEL: Starting pattern match
  Morphed node: t20: ch = BRNCH BasicBlock:ch<if.then 0x5d8e2caa1098>, t24
ISEL: Match complete!

ISEL: Starting selection on root node: t24: ch = br_cc t10, seteq:ch, t11, t12, BasicBlock:ch<if.else 0x5d8e2caa11b8>
ISEL: Starting pattern match
  Initial Opcode index to 358
  Skipped scope entry (due to false predicate) at index 362, continuing at 388
  Skipped scope entry (due to false predicate) at index 389, continuing at 415
  Skipped scope entry (due to false predicate) at index 416, continuing at 442
  Skipped scope entry (due to false predicate) at index 443, continuing at 469
  Skipped scope entry (due to false predicate) at index 470, continuing at 496
Creating new machine node: t25: i32 = CMP t11, t12
  Created node: t25: i32 = CMP t11, t12
  Morphed node: t24: ch = BRNCHZ t25, BasicBlock:ch<if.else 0x5d8e2caa11b8>, t10
ISEL: Match complete!

ISEL: Starting selection on root node: t11: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t10, FrameIndex:i32<1>, undef:i32
ISEL: Starting pattern match
  Initial Opcode index to 254
  Morphed node: t11: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> FrameIndex:i32<1>, t10
ISEL: Match complete!

ISEL: Starting selection on root node: t12: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t10, FrameIndex:i32<2>, undef:i32
ISEL: Starting pattern match
  Initial Opcode index to 254
  Morphed node: t12: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> FrameIndex:i32<2>, t10
ISEL: Match complete!

ISEL: Starting selection on root node: t10: ch = store<(store (s32) into %ir.b.addr)> t8, t4, FrameIndex:i32<2>, undef:i32
ISEL: Starting pattern match
  Initial Opcode index to 53
  Match failed at index 59
  Continuing at 77
  Morphed node: t10: ch = STR<Mem:(store (s32) into %ir.b.addr)> t4, FrameIndex:i32<2>, t8
ISEL: Match complete!

ISEL: Starting selection on root node: t8: ch = store<(store (s32) into %ir.a.addr)> t0, t2, FrameIndex:i32<1>, undef:i32
ISEL: Starting pattern match
  Initial Opcode index to 53
  Match failed at index 59
  Continuing at 77
  Morphed node: t8: ch = STR<Mem:(store (s32) into %ir.a.addr)> t2, FrameIndex:i32<1>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i32,ch = CopyFromReg t0, Register:i32 %1

ISEL: Starting selection on root node: t2: i32,ch = CopyFromReg t0, Register:i32 %0

ISEL: Starting selection on root node: t19: ch = BasicBlock<if.then 0x5d8e2caa1098>

ISEL: Starting selection on root node: t17: ch = BasicBlock<if.else 0x5d8e2caa11b8>

ISEL: Starting selection on root node: t9: i32 = FrameIndex<2>
ISEL: Starting pattern match
  Initial Opcode index to 527
Creating constant: t27: i32 = TargetConstant<0>
Creating new machine node: t28: i32 = I_ALLOCA TargetConstant:i32<0>
  Created node: t28: i32 = I_ALLOCA TargetConstant:i32<0>
  Morphed node: t9: i32 = ADD TargetFrameIndex:i32<2>, t28
ISEL: Match complete!

ISEL: Starting selection on root node: t5: i32 = FrameIndex<1>
ISEL: Starting pattern match
  Initial Opcode index to 527
  Created node: t28: i32 = I_ALLOCA TargetConstant:i32<0>
  Morphed node: t5: i32 = ADD TargetFrameIndex:i32<1>, t28
ISEL: Match complete!

ISEL: Starting selection on root node: t3: i32 = Register %1

ISEL: Starting selection on root node: t1: i32 = Register %0

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:

Selected selection DAG: %bb.0 '_Z6branchii:entry'
SelectionDAG has 20 nodes:
  t0: ch,glue = EntryToken
  t5: i32 = ADD TargetFrameIndex:i32<1>, t28
  t9: i32 = ADD TargetFrameIndex:i32<2>, t28
    t4: i32,ch = CopyFromReg t0, Register:i32 %1
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t8: ch = STR<Mem:(store (s32) into %ir.a.addr)> t2, t5, t0
  t10: ch = STR<Mem:(store (s32) into %ir.b.addr)> t4, t9, t8
  t28: i32 = I_ALLOCA TargetConstant:i32<0>
        t11: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> t5, t10
        t12: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> t9, t10
      t25: i32 = CMP t11, t12
    t24: ch = BRNCHZ t25, BasicBlock:ch<if.else 0x5d8e2caa11b8>, t10
  t20: ch = BRNCH BasicBlock:ch<if.then 0x5d8e2caa1098>, t24


********** List Scheduling %bb.0 'entry' **********
SU(0): t20: ch = BRNCH BasicBlock:ch<if.then 0x5d8e2caa1098>, t24

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 7
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t24: ch = BRNCHZ t25, BasicBlock:ch<if.else 0x5d8e2caa11b8>, t10

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 1
  Predecessors:
    SU(9): Data Latency=1
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t10: ch = STR<Mem:(store (s32) into %ir.b.addr)> t4, t9, t8

  # preds left       : 3
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 4
  Predecessors:
    SU(8): Data Latency=1
    SU(7): Data Latency=1
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=1 Barrier
    SU(10): Ord  Latency=1 Barrier
    SU(11): Ord  Latency=1 Barrier
SU(3): t8: ch = STR<Mem:(store (s32) into %ir.a.addr)> t2, t5, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 5
  Predecessors:
    SU(6): Data Latency=1
    SU(4): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
SU(4): t5: i32 = ADD TargetFrameIndex:i32<1>, t28

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 6
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(3): Data Latency=1
    SU(11): Data Latency=1
SU(5): t28: i32 = I_ALLOCA TargetConstant:i32<0>

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 7
  Successors:
    SU(4): Data Latency=1
    SU(7): Data Latency=1
SU(6): t2: i32,ch = CopyFromReg t0, Register:i32 %0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(3): Data Latency=1
SU(7): t9: i32 = ADD TargetFrameIndex:i32<2>, t28

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(2): Data Latency=1
    SU(10): Data Latency=1
SU(8): t4: i32,ch = CopyFromReg t0, Register:i32 %1

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=1
SU(9): t25: i32 = CMP t11, t12

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 2
  Predecessors:
    SU(11): Data Latency=1
    SU(10): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(10): t12: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> t9, t10

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 3
  Predecessors:
    SU(7): Data Latency=1
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(9): Data Latency=1
SU(11): t11: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> t5, t10

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(9): Data Latency=1

Examining Available:
Height 0: SU(0): t20: ch = BRNCH BasicBlock:ch<if.then 0x5d8e2caa1098>, t24


*** Scheduling [0]: SU(0): t20: ch = BRNCH BasicBlock:ch<if.then 0x5d8e2caa1098>, t24


Examining Available:
Height 1: SU(1): t24: ch = BRNCHZ t25, BasicBlock:ch<if.else 0x5d8e2caa11b8>, t10


*** Scheduling [1]: SU(1): t24: ch = BRNCHZ t25, BasicBlock:ch<if.else 0x5d8e2caa11b8>, t10


Examining Available:
Height 2: SU(9): t25: i32 = CMP t11, t12


*** Scheduling [2]: SU(9): t25: i32 = CMP t11, t12


Examining Available:
Height 3: SU(10): t12: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> t9, t10

Height 3: SU(11): t11: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> t5, t10


*** Scheduling [3]: SU(10): t12: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> t9, t10


Examining Available:
Height 3: SU(11): t11: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> t5, t10


*** Scheduling [4]: SU(11): t11: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> t5, t10


Examining Available:
Height 5: SU(2): t10: ch = STR<Mem:(store (s32) into %ir.b.addr)> t4, t9, t8


*** Scheduling [5]: SU(2): t10: ch = STR<Mem:(store (s32) into %ir.b.addr)> t4, t9, t8


Examining Available:
Height 6: SU(7): t9: i32 = ADD TargetFrameIndex:i32<2>, t28

Height 6: SU(3): t8: ch = STR<Mem:(store (s32) into %ir.a.addr)> t2, t5, t0

Height 6: SU(8): t4: i32,ch = CopyFromReg t0, Register:i32 %1


*** Scheduling [6]: SU(7): t9: i32 = ADD TargetFrameIndex:i32<2>, t28


Examining Available:
Height 6: SU(3): t8: ch = STR<Mem:(store (s32) into %ir.a.addr)> t2, t5, t0

Height 6: SU(8): t4: i32,ch = CopyFromReg t0, Register:i32 %1


*** Scheduling [7]: SU(3): t8: ch = STR<Mem:(store (s32) into %ir.a.addr)> t2, t5, t0


Examining Available:
Height 8: SU(4): t5: i32 = ADD TargetFrameIndex:i32<1>, t28

Height 8: SU(6): t2: i32,ch = CopyFromReg t0, Register:i32 %0

Height 6: SU(8): t4: i32,ch = CopyFromReg t0, Register:i32 %1


*** Scheduling [8]: SU(4): t5: i32 = ADD TargetFrameIndex:i32<1>, t28


Examining Available:
Height 9: SU(5): t28: i32 = I_ALLOCA TargetConstant:i32<0>

Height 8: SU(6): t2: i32,ch = CopyFromReg t0, Register:i32 %0

Height 6: SU(8): t4: i32,ch = CopyFromReg t0, Register:i32 %1


*** Scheduling [9]: SU(5): t28: i32 = I_ALLOCA TargetConstant:i32<0>


Examining Available:
Height 8: SU(6): t2: i32,ch = CopyFromReg t0, Register:i32 %0

Height 6: SU(8): t4: i32,ch = CopyFromReg t0, Register:i32 %1


*** Scheduling [10]: SU(6): t2: i32,ch = CopyFromReg t0, Register:i32 %0


Examining Available:
Height 6: SU(8): t4: i32,ch = CopyFromReg t0, Register:i32 %1


*** Scheduling [11]: SU(8): t4: i32,ch = CopyFromReg t0, Register:i32 %1

*** Final schedule ***
SU(8): t4: i32,ch = CopyFromReg t0, Register:i32 %1

SU(6): t2: i32,ch = CopyFromReg t0, Register:i32 %0

SU(5): t28: i32 = I_ALLOCA TargetConstant:i32<0>

SU(4): t5: i32 = ADD TargetFrameIndex:i32<1>, t28

SU(3): t8: ch = STR<Mem:(store (s32) into %ir.a.addr)> t2, t5, t0

SU(7): t9: i32 = ADD TargetFrameIndex:i32<2>, t28

SU(2): t10: ch = STR<Mem:(store (s32) into %ir.b.addr)> t4, t9, t8

SU(11): t11: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> t5, t10

SU(10): t12: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> t9, t10

SU(9): t25: i32 = CMP t11, t12

SU(1): t24: ch = BRNCHZ t25, BasicBlock:ch<if.else 0x5d8e2caa11b8>, t10

SU(0): t20: ch = BRNCH BasicBlock:ch<if.then 0x5d8e2caa1098>, t24


Total amount of phi nodes to update: 0
Creating constant: t2: i32 = Constant<0>
Creating new node: t3: i32 = undef
Creating new node: t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32
Creating new node: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
Creating new node: t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>

Initial selection DAG: %bb.2 '_Z6branchii:if.else'
SelectionDAG has 9 nodes:
  t2: i32 = Constant<0>
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32
    t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
  t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>



Combining: t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>

Combining: t7: ch = BasicBlock<return 0x5d8e2caa12d8>

Combining: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32

Combining: t5: i32 = FrameIndex<0>

Combining: t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32

Combining: t3: i32 = undef

Combining: t1: i32 = FrameIndex<2>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.2 '_Z6branchii:if.else'
SelectionDAG has 8 nodes:
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32
    t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
  t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>



Legalizing node: t7: ch = BasicBlock<return 0x5d8e2caa12d8>
Analyzing result type: ch
Legal result type
Legally typed node: t7: ch = BasicBlock<return 0x5d8e2caa12d8>

Legalizing node: t5: i32 = FrameIndex<0>
Analyzing result type: i32
Legal result type
Legally typed node: t5: i32 = FrameIndex<0>

Legalizing node: t3: i32 = undef
Analyzing result type: i32
Legal result type
Legally typed node: t3: i32 = undef

Legalizing node: t1: i32 = FrameIndex<2>
Analyzing result type: i32
Legal result type
Legally typed node: t1: i32 = FrameIndex<2>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i32 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i32 = undef
Legal operand
Legally typed node: t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32

Legalizing node: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
Analyzing result type: ch
Legal result type
Analyzing operand: t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32
Legal operand
Analyzing operand: t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32
Legal operand
Analyzing operand: t5: i32 = FrameIndex<0>
Legal operand
Analyzing operand: t3: i32 = undef
Legal operand
Legally typed node: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32

Legalizing node: t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>
Analyzing result type: ch
Legal result type
Analyzing operand: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
Legal operand
Analyzing operand: t7: ch = BasicBlock<return 0x5d8e2caa12d8>
Legal operand
Legally typed node: t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>

Legalizing node: t65535: ch = handlenode t8
Analyzing result type: ch
Legal result type
Analyzing operand: t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>
Legal operand
Legally typed node: t65535: ch = handlenode t8

Type-legalized selection DAG: %bb.2 '_Z6branchii:if.else'
SelectionDAG has 8 nodes:
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32
    t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
  t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>



Legalizing: t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>
Legal node: nothing to do

Legalizing: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32
Legalizing non-extending load operation

Legalizing: t7: ch = BasicBlock<return 0x5d8e2caa12d8>
Legal node: nothing to do

Legalizing: t5: i32 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t3: i32 = undef
Legal node: nothing to do

Legalizing: t1: i32 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.2 '_Z6branchii:if.else'
SelectionDAG has 8 nodes:
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32
    t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
  t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>



Legalizing: t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>
Legal node: nothing to do

Combining: t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>

Legalizing: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32

Legalizing: t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32
Legalizing non-extending load operation

Combining: t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32

Legalizing: t7: ch = BasicBlock<return 0x5d8e2caa12d8>
Legal node: nothing to do

Combining: t7: ch = BasicBlock<return 0x5d8e2caa12d8>

Legalizing: t5: i32 = FrameIndex<0>
Legal node: nothing to do

Combining: t5: i32 = FrameIndex<0>

Legalizing: t3: i32 = undef
Legal node: nothing to do

Combining: t3: i32 = undef

Legalizing: t1: i32 = FrameIndex<2>
Legal node: nothing to do

Combining: t1: i32 = FrameIndex<2>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.2 '_Z6branchii:if.else'
SelectionDAG has 8 nodes:
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32
    t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
  t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>


Writing '/tmp/dag._Z6branchii-c1cbc9.dot'...  done. 
Trying 'xdg-open' program... Remember to erase graph file: /tmp/dag._Z6branchii-c1cbc9.dot
===== Instruction selection begins: %bb.2 'if.else'

ISEL: Starting selection on root node: t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>
ISEL: Starting pattern match
  Initial Opcode index to 331
  Morphed node: t8: ch = BRNCH BasicBlock:ch<return 0x5d8e2caa12d8>, t6
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
ISEL: Starting pattern match
  Initial Opcode index to 53
  Match failed at index 59
  Continuing at 77
  Morphed node: t6: ch = STR<Mem:(store (s32) into %ir.retval)> t4, FrameIndex:i32<0>, t4:1
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i32,ch = load<(dereferenceable load (s32) from %ir.b.addr)> t0, FrameIndex:i32<2>, undef:i32
ISEL: Starting pattern match
  Initial Opcode index to 254
  Morphed node: t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> FrameIndex:i32<2>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t7: ch = BasicBlock<return 0x5d8e2caa12d8>

ISEL: Starting selection on root node: t5: i32 = FrameIndex<0>
ISEL: Starting pattern match
  Initial Opcode index to 527
Creating constant: t10: i32 = TargetConstant<0>
Creating new machine node: t11: i32 = I_ALLOCA TargetConstant:i32<0>
  Created node: t11: i32 = I_ALLOCA TargetConstant:i32<0>
  Morphed node: t5: i32 = ADD TargetFrameIndex:i32<0>, t11
ISEL: Match complete!

ISEL: Starting selection on root node: t1: i32 = FrameIndex<2>
ISEL: Starting pattern match
  Initial Opcode index to 527
  Created node: t11: i32 = I_ALLOCA TargetConstant:i32<0>
  Morphed node: t1: i32 = ADD TargetFrameIndex:i32<2>, t11
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:

Selected selection DAG: %bb.2 '_Z6branchii:if.else'
SelectionDAG has 11 nodes:
    t1: i32 = ADD TargetFrameIndex:i32<2>, t11
    t0: ch,glue = EntryToken
  t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> t1, t0
  t11: i32 = I_ALLOCA TargetConstant:i32<0>
      t5: i32 = ADD TargetFrameIndex:i32<0>, t11
    t6: ch = STR<Mem:(store (s32) into %ir.retval)> t4, t5, t4:1
  t8: ch = BRNCH BasicBlock:ch<return 0x5d8e2caa12d8>, t6


********** List Scheduling %bb.2 'if.else' **********
SU(0): t8: ch = BRNCH BasicBlock:ch<return 0x5d8e2caa12d8>, t6

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t6: ch = STR<Mem:(store (s32) into %ir.retval)> t4, t5, t4:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(4): Data Latency=1
    SU(2): Data Latency=1
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t5: i32 = ADD TargetFrameIndex:i32<0>, t11

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t11: i32 = I_ALLOCA TargetConstant:i32<0>

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(2): Data Latency=1
    SU(5): Data Latency=1
SU(4): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> t1, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(1): Data Latency=1
    SU(1): Ord  Latency=1 Barrier
SU(5): t1: i32 = ADD TargetFrameIndex:i32<2>, t11

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(4): Data Latency=1

Examining Available:
Height 0: SU(0): t8: ch = BRNCH BasicBlock:ch<return 0x5d8e2caa12d8>, t6


*** Scheduling [0]: SU(0): t8: ch = BRNCH BasicBlock:ch<return 0x5d8e2caa12d8>, t6


Examining Available:
Height 1: SU(1): t6: ch = STR<Mem:(store (s32) into %ir.retval)> t4, t5, t4:1


*** Scheduling [1]: SU(1): t6: ch = STR<Mem:(store (s32) into %ir.retval)> t4, t5, t4:1


Examining Available:
Height 2: SU(2): t5: i32 = ADD TargetFrameIndex:i32<0>, t11

Height 2: SU(4): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> t1, t0


*** Scheduling [2]: SU(2): t5: i32 = ADD TargetFrameIndex:i32<0>, t11


Examining Available:
Height 2: SU(4): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> t1, t0


*** Scheduling [3]: SU(4): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> t1, t0


Examining Available:
Height 4: SU(5): t1: i32 = ADD TargetFrameIndex:i32<2>, t11


*** Scheduling [4]: SU(5): t1: i32 = ADD TargetFrameIndex:i32<2>, t11


Examining Available:
Height 5: SU(3): t11: i32 = I_ALLOCA TargetConstant:i32<0>


*** Scheduling [5]: SU(3): t11: i32 = I_ALLOCA TargetConstant:i32<0>

*** Final schedule ***
SU(3): t11: i32 = I_ALLOCA TargetConstant:i32<0>

SU(5): t1: i32 = ADD TargetFrameIndex:i32<2>, t11

SU(4): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.b.addr)> t1, t0

SU(2): t5: i32 = ADD TargetFrameIndex:i32<0>, t11

SU(1): t6: ch = STR<Mem:(store (s32) into %ir.retval)> t4, t5, t4:1

SU(0): t8: ch = BRNCH BasicBlock:ch<return 0x5d8e2caa12d8>, t6


Total amount of phi nodes to update: 0
Creating constant: t2: i32 = Constant<0>
Creating new node: t3: i32 = undef
Creating new node: t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32
Creating new node: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
Creating new node: t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>

Initial selection DAG: %bb.1 '_Z6branchii:if.then'
SelectionDAG has 9 nodes:
  t2: i32 = Constant<0>
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32
    t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
  t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>



Combining: t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>

Combining: t7: ch = BasicBlock<return 0x5d8e2caa12d8>

Combining: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32

Combining: t5: i32 = FrameIndex<0>

Combining: t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32

Combining: t3: i32 = undef

Combining: t1: i32 = FrameIndex<1>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.1 '_Z6branchii:if.then'
SelectionDAG has 8 nodes:
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32
    t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
  t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>



Legalizing node: t7: ch = BasicBlock<return 0x5d8e2caa12d8>
Analyzing result type: ch
Legal result type
Legally typed node: t7: ch = BasicBlock<return 0x5d8e2caa12d8>

Legalizing node: t5: i32 = FrameIndex<0>
Analyzing result type: i32
Legal result type
Legally typed node: t5: i32 = FrameIndex<0>

Legalizing node: t3: i32 = undef
Analyzing result type: i32
Legal result type
Legally typed node: t3: i32 = undef

Legalizing node: t1: i32 = FrameIndex<1>
Analyzing result type: i32
Legal result type
Legally typed node: t1: i32 = FrameIndex<1>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i32 = FrameIndex<1>
Legal operand
Analyzing operand: t3: i32 = undef
Legal operand
Legally typed node: t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32

Legalizing node: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
Analyzing result type: ch
Legal result type
Analyzing operand: t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32
Legal operand
Analyzing operand: t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32
Legal operand
Analyzing operand: t5: i32 = FrameIndex<0>
Legal operand
Analyzing operand: t3: i32 = undef
Legal operand
Legally typed node: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32

Legalizing node: t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>
Analyzing result type: ch
Legal result type
Analyzing operand: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
Legal operand
Analyzing operand: t7: ch = BasicBlock<return 0x5d8e2caa12d8>
Legal operand
Legally typed node: t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>

Legalizing node: t65535: ch = handlenode t8
Analyzing result type: ch
Legal result type
Analyzing operand: t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>
Legal operand
Legally typed node: t65535: ch = handlenode t8

Type-legalized selection DAG: %bb.1 '_Z6branchii:if.then'
SelectionDAG has 8 nodes:
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32
    t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
  t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>



Legalizing: t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>
Legal node: nothing to do

Legalizing: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32
Legalizing non-extending load operation

Legalizing: t7: ch = BasicBlock<return 0x5d8e2caa12d8>
Legal node: nothing to do

Legalizing: t5: i32 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t3: i32 = undef
Legal node: nothing to do

Legalizing: t1: i32 = FrameIndex<1>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.1 '_Z6branchii:if.then'
SelectionDAG has 8 nodes:
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32
    t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
  t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>



Legalizing: t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>
Legal node: nothing to do

Combining: t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>

Legalizing: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32

Legalizing: t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32
Legalizing non-extending load operation

Combining: t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32

Legalizing: t7: ch = BasicBlock<return 0x5d8e2caa12d8>
Legal node: nothing to do

Combining: t7: ch = BasicBlock<return 0x5d8e2caa12d8>

Legalizing: t5: i32 = FrameIndex<0>
Legal node: nothing to do

Combining: t5: i32 = FrameIndex<0>

Legalizing: t3: i32 = undef
Legal node: nothing to do

Combining: t3: i32 = undef

Legalizing: t1: i32 = FrameIndex<1>
Legal node: nothing to do

Combining: t1: i32 = FrameIndex<1>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.1 '_Z6branchii:if.then'
SelectionDAG has 8 nodes:
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32
    t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
  t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>


Writing '/tmp/dag._Z6branchii-a90b87.dot'...  done. 
Trying 'xdg-open' program... Remember to erase graph file: /tmp/dag._Z6branchii-a90b87.dot
===== Instruction selection begins: %bb.1 'if.then'

ISEL: Starting selection on root node: t8: ch = br t6, BasicBlock:ch<return 0x5d8e2caa12d8>
ISEL: Starting pattern match
  Initial Opcode index to 331
  Morphed node: t8: ch = BRNCH BasicBlock:ch<return 0x5d8e2caa12d8>, t6
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch = store<(store (s32) into %ir.retval)> t4:1, t4, FrameIndex:i32<0>, undef:i32
ISEL: Starting pattern match
  Initial Opcode index to 53
  Match failed at index 59
  Continuing at 77
  Morphed node: t6: ch = STR<Mem:(store (s32) into %ir.retval)> t4, FrameIndex:i32<0>, t4:1
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i32,ch = load<(dereferenceable load (s32) from %ir.a.addr)> t0, FrameIndex:i32<1>, undef:i32
ISEL: Starting pattern match
  Initial Opcode index to 254
  Morphed node: t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> FrameIndex:i32<1>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t7: ch = BasicBlock<return 0x5d8e2caa12d8>

ISEL: Starting selection on root node: t5: i32 = FrameIndex<0>
ISEL: Starting pattern match
  Initial Opcode index to 527
Creating constant: t10: i32 = TargetConstant<0>
Creating new machine node: t11: i32 = I_ALLOCA TargetConstant:i32<0>
  Created node: t11: i32 = I_ALLOCA TargetConstant:i32<0>
  Morphed node: t5: i32 = ADD TargetFrameIndex:i32<0>, t11
ISEL: Match complete!

ISEL: Starting selection on root node: t1: i32 = FrameIndex<1>
ISEL: Starting pattern match
  Initial Opcode index to 527
  Created node: t11: i32 = I_ALLOCA TargetConstant:i32<0>
  Morphed node: t1: i32 = ADD TargetFrameIndex:i32<1>, t11
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:

Selected selection DAG: %bb.1 '_Z6branchii:if.then'
SelectionDAG has 11 nodes:
    t1: i32 = ADD TargetFrameIndex:i32<1>, t11
    t0: ch,glue = EntryToken
  t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> t1, t0
  t11: i32 = I_ALLOCA TargetConstant:i32<0>
      t5: i32 = ADD TargetFrameIndex:i32<0>, t11
    t6: ch = STR<Mem:(store (s32) into %ir.retval)> t4, t5, t4:1
  t8: ch = BRNCH BasicBlock:ch<return 0x5d8e2caa12d8>, t6


********** List Scheduling %bb.1 'if.then' **********
SU(0): t8: ch = BRNCH BasicBlock:ch<return 0x5d8e2caa12d8>, t6

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t6: ch = STR<Mem:(store (s32) into %ir.retval)> t4, t5, t4:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(4): Data Latency=1
    SU(2): Data Latency=1
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t5: i32 = ADD TargetFrameIndex:i32<0>, t11

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t11: i32 = I_ALLOCA TargetConstant:i32<0>

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(2): Data Latency=1
    SU(5): Data Latency=1
SU(4): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> t1, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(1): Data Latency=1
    SU(1): Ord  Latency=1 Barrier
SU(5): t1: i32 = ADD TargetFrameIndex:i32<1>, t11

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(4): Data Latency=1

Examining Available:
Height 0: SU(0): t8: ch = BRNCH BasicBlock:ch<return 0x5d8e2caa12d8>, t6


*** Scheduling [0]: SU(0): t8: ch = BRNCH BasicBlock:ch<return 0x5d8e2caa12d8>, t6


Examining Available:
Height 1: SU(1): t6: ch = STR<Mem:(store (s32) into %ir.retval)> t4, t5, t4:1


*** Scheduling [1]: SU(1): t6: ch = STR<Mem:(store (s32) into %ir.retval)> t4, t5, t4:1


Examining Available:
Height 2: SU(2): t5: i32 = ADD TargetFrameIndex:i32<0>, t11

Height 2: SU(4): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> t1, t0


*** Scheduling [2]: SU(2): t5: i32 = ADD TargetFrameIndex:i32<0>, t11


Examining Available:
Height 2: SU(4): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> t1, t0


*** Scheduling [3]: SU(4): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> t1, t0


Examining Available:
Height 4: SU(5): t1: i32 = ADD TargetFrameIndex:i32<1>, t11


*** Scheduling [4]: SU(5): t1: i32 = ADD TargetFrameIndex:i32<1>, t11


Examining Available:
Height 5: SU(3): t11: i32 = I_ALLOCA TargetConstant:i32<0>


*** Scheduling [5]: SU(3): t11: i32 = I_ALLOCA TargetConstant:i32<0>

*** Final schedule ***
SU(3): t11: i32 = I_ALLOCA TargetConstant:i32<0>

SU(5): t1: i32 = ADD TargetFrameIndex:i32<1>, t11

SU(4): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.a.addr)> t1, t0

SU(2): t5: i32 = ADD TargetFrameIndex:i32<0>, t11

SU(1): t6: ch = STR<Mem:(store (s32) into %ir.retval)> t4, t5, t4:1

SU(0): t8: ch = BRNCH BasicBlock:ch<return 0x5d8e2caa12d8>, t6


Total amount of phi nodes to update: 0
Creating constant: t2: i32 = Constant<0>
Creating new node: t3: i32 = undef
Creating new node: t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32
Creating new node: t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4
Creating new node: t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1

Initial selection DAG: %bb.3 '_Z6branchii:return'
SelectionDAG has 8 nodes:
  t0: ch,glue = EntryToken
  t2: i32 = Constant<0>
    t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32
  t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4
  t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1



Combining: t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1

Combining: t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4

Combining: t5: i32 = Register $r0

Combining: t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32

Combining: t3: i32 = undef

Combining: t1: i32 = FrameIndex<0>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.3 '_Z6branchii:return'
SelectionDAG has 7 nodes:
  t0: ch,glue = EntryToken
    t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32
  t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4
  t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1



Legalizing node: t5: i32 = Register $r0
Ignoring node results
Legally typed node: t5: i32 = Register $r0

Legalizing node: t3: i32 = undef
Analyzing result type: i32
Legal result type
Legally typed node: t3: i32 = undef

Legalizing node: t1: i32 = FrameIndex<0>
Analyzing result type: i32
Legal result type
Legally typed node: t1: i32 = FrameIndex<0>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i32 = FrameIndex<0>
Legal operand
Analyzing operand: t3: i32 = undef
Legal operand
Legally typed node: t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32

Legalizing node: t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32
Legal operand
Legally typed node: t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4

Legalizing node: t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1
Analyzing result type: ch
Legal result type
Analyzing operand: t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4
Legal operand
Analyzing operand: t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4
Legal operand
Legally typed node: t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1

Legalizing node: t65535: ch = handlenode t7
Analyzing result type: ch
Legal result type
Analyzing operand: t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1
Legal operand
Legally typed node: t65535: ch = handlenode t7

Type-legalized selection DAG: %bb.3 '_Z6branchii:return'
SelectionDAG has 7 nodes:
  t0: ch,glue = EntryToken
    t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32
  t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4
  t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1



Legalizing: t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1
Legal node: nothing to do

Legalizing: t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4
Legal node: nothing to do

Legalizing: t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32
Legalizing non-extending load operation

Legalizing: t5: i32 = Register $r0

Legalizing: t3: i32 = undef
Legal node: nothing to do

Legalizing: t1: i32 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.3 '_Z6branchii:return'
SelectionDAG has 7 nodes:
  t0: ch,glue = EntryToken
    t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32
  t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4
  t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1



Legalizing: t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1
Legal node: nothing to do

Combining: t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1

Legalizing: t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4
Legal node: nothing to do

Combining: t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4

Legalizing: t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32
Legalizing non-extending load operation

Combining: t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32

Legalizing: t5: i32 = Register $r0

Combining: t5: i32 = Register $r0

Legalizing: t3: i32 = undef
Legal node: nothing to do

Combining: t3: i32 = undef

Legalizing: t1: i32 = FrameIndex<0>
Legal node: nothing to do

Combining: t1: i32 = FrameIndex<0>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.3 '_Z6branchii:return'
SelectionDAG has 7 nodes:
  t0: ch,glue = EntryToken
    t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32
  t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4
  t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1


Writing '/tmp/dag._Z6branchii-9d190f.dot'...  done. 
Trying 'xdg-open' program... Remember to erase graph file: /tmp/dag._Z6branchii-9d190f.dot
===== Instruction selection begins: %bb.3 'return'

ISEL: Starting selection on root node: t7: ch = TinyGPUISD::Ret t6, Register:i32 $r0, t6:1
ISEL: Starting pattern match
  Initial Opcode index to 272
  Morphed node: t7: ch = PseudoRET Register:i32 $r0, t6, t6:1
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4

ISEL: Starting selection on root node: t4: i32,ch = load<(dereferenceable load (s32) from %ir.retval)> t0, FrameIndex:i32<0>, undef:i32
ISEL: Starting pattern match
  Initial Opcode index to 254
  Morphed node: t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.retval)> FrameIndex:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t5: i32 = Register $r0

ISEL: Starting selection on root node: t1: i32 = FrameIndex<0>
ISEL: Starting pattern match
  Initial Opcode index to 527
Creating constant: t9: i32 = TargetConstant<0>
Creating new machine node: t10: i32 = I_ALLOCA TargetConstant:i32<0>
  Created node: t10: i32 = I_ALLOCA TargetConstant:i32<0>
  Morphed node: t1: i32 = ADD TargetFrameIndex:i32<0>, t10
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:

Selected selection DAG: %bb.3 '_Z6branchii:return'
SelectionDAG has 9 nodes:
  t0: ch,glue = EntryToken
        t10: i32 = I_ALLOCA TargetConstant:i32<0>
      t1: i32 = ADD TargetFrameIndex:i32<0>, t10
    t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.retval)> t1, t0
  t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4
  t7: ch = PseudoRET Register:i32 $r0, t6, t6:1


********** List Scheduling %bb.3 'return' **********
SU(0): t7: ch = PseudoRET Register:i32 $r0, t6, t6:1

    t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1
SU(1): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.retval)> t1, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Data Latency=1
SU(2): t1: i32 = ADD TargetFrameIndex:i32<0>, t10

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t10: i32 = I_ALLOCA TargetConstant:i32<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1

Examining Available:
Height 0: SU(0): t7: ch = PseudoRET Register:i32 $r0, t6, t6:1

    t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4


*** Scheduling [0]: SU(0): t7: ch = PseudoRET Register:i32 $r0, t6, t6:1

    t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4


Examining Available:
Height 1: SU(1): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.retval)> t1, t0


*** Scheduling [1]: SU(1): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.retval)> t1, t0


Examining Available:
Height 2: SU(2): t1: i32 = ADD TargetFrameIndex:i32<0>, t10


*** Scheduling [2]: SU(2): t1: i32 = ADD TargetFrameIndex:i32<0>, t10


Examining Available:
Height 3: SU(3): t10: i32 = I_ALLOCA TargetConstant:i32<0>


*** Scheduling [3]: SU(3): t10: i32 = I_ALLOCA TargetConstant:i32<0>

*** Final schedule ***
SU(3): t10: i32 = I_ALLOCA TargetConstant:i32<0>

SU(2): t1: i32 = ADD TargetFrameIndex:i32<0>, t10

SU(1): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.retval)> t1, t0

SU(0): t7: ch = PseudoRET Register:i32 $r0, t6, t6:1

    t6: ch,glue = CopyToReg t0, Register:i32 $r0, t4


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function _Z6branchii: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP]
  fi#1: size=4, align=4, at location [SP]
  fi#2: size=4, align=4, at location [SP]
Function Live Ins: $r0 in %0, $r1 in %1

bb.0.entry:
  successors: %bb.1, %bb.2
  liveins: $r0, $r1
  %1:gpr = COPY $r1
  %0:gpr = COPY $r0
  %2:gpr = I_ALLOCA 0
  %3:gpr = ADD %stack.1.a.addr, %2:gpr
  STR %0:gpr, %3:gpr :: (store (s32) into %ir.a.addr)
  %4:gpr = ADD %stack.2.b.addr, %2:gpr
  STR %1:gpr, %4:gpr :: (store (s32) into %ir.b.addr)
  %5:gpr = LDR %3:gpr :: (dereferenceable load (s32) from %ir.a.addr)
  %6:gpr = LDR %4:gpr :: (dereferenceable load (s32) from %ir.b.addr)
  %7:gpr = CMP killed %5:gpr, killed %6:gpr
  BRNCHZ killed %7:gpr, %bb.2
  BRNCH %bb.1

bb.1.if.then:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %12:gpr = I_ALLOCA 0
  %13:gpr = ADD %stack.1.a.addr, %12:gpr
  %14:gpr = LDR killed %13:gpr :: (dereferenceable load (s32) from %ir.a.addr)
  %15:gpr = ADD %stack.0.retval, %12:gpr
  STR killed %14:gpr, killed %15:gpr :: (store (s32) into %ir.retval)
  BRNCH %bb.3

bb.2.if.else:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %8:gpr = I_ALLOCA 0
  %9:gpr = ADD %stack.2.b.addr, %8:gpr
  %10:gpr = LDR killed %9:gpr :: (dereferenceable load (s32) from %ir.b.addr)
  %11:gpr = ADD %stack.0.retval, %8:gpr
  STR killed %10:gpr, killed %11:gpr :: (store (s32) into %ir.retval)
  BRNCH %bb.3

bb.3.return:
; predecessors: %bb.2, %bb.1

  %16:gpr = I_ALLOCA 0
  %17:gpr = ADD %stack.0.retval, killed %16:gpr
  %18:gpr = LDR killed %17:gpr :: (dereferenceable load (s32) from %ir.retval)
  $r0 = COPY %18:gpr
  PseudoRET implicit $r0

# End machine code for function _Z6branchii.

Skipping pass 'Two-Address instruction pass' on function _Z6branchii
********** REWRITING TWO-ADDR INSTRS **********
********** Function: _Z6branchii
********** FAST REGISTER ALLOCATION **********
********** Function: _Z6branchii

Allocating bb.0.entry:
  successors: %bb.1, %bb.2
  liveins: $r0, $r1
  %1:gpr = COPY $r1
  %0:gpr = COPY $r0
  %2:gpr = I_ALLOCA 0
  %3:gpr = ADD %stack.1.a.addr, %2:gpr
  STR %0:gpr, %3:gpr :: (store (s32) into %ir.a.addr)
  %4:gpr = ADD %stack.2.b.addr, %2:gpr
  STR %1:gpr, %4:gpr :: (store (s32) into %ir.b.addr)
  %5:gpr = LDR %3:gpr :: (dereferenceable load (s32) from %ir.a.addr)
  %6:gpr = LDR %4:gpr :: (dereferenceable load (s32) from %ir.b.addr)
  %7:gpr = CMP killed %5:gpr, killed %6:gpr
  BRNCHZ killed %7:gpr, %bb.2
  BRNCH %bb.1

>> BRNCH %bb.1
Regs:
<< BRNCH %bb.1

>> BRNCHZ killed %7:gpr, %bb.2
Regs:
Search register for %7 in class GPR with hint $noreg
AllocationOrder(GPR) = [ $r0 $r1 $r2 $r3 $r4 $r5 $r6 $r7 $r10 $r8 $r9 ]
	Register: $r0 Cost: 0 BestCost: 4294967295
Assigning %7 to $r0
<< BRNCHZ killed $r0, %bb.2

>> %7:gpr = CMP killed %5:gpr, killed %6:gpr
Regs: R0=%7
In def of %7 use existing assignment to $r0
Freeing $r0: %7
Search register for %5 in class GPR with hint $noreg
	Register: $r0 Cost: 0 BestCost: 4294967295
Assigning %5 to $r0
Search register for %6 in class GPR with hint $noreg
	Register: $r0 already used in instr.
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %6 to $r1
<< $r0 = CMP killed $r0, killed $r1

>> %6:gpr = LDR %4:gpr :: (dereferenceable load (s32) from %ir.b.addr)
Regs: R0=%5 R1=%6
In def of %6 use existing assignment to $r1
Freeing $r1: %6
Search register for %4 in class GPR with hint $noreg
	Register: $r0 Cost: 100 BestCost: 4294967295
	Register: $r1 Cost: 0 BestCost: 100
Assigning %4 to $r1
<< $r1 = LDR killed $r1 :: (dereferenceable load (s32) from %ir.b.addr)

>> %5:gpr = LDR %3:gpr :: (dereferenceable load (s32) from %ir.a.addr)
Regs: R0=%5 R1=%4
In def of %5 use existing assignment to $r0
Freeing $r0: %5
Search register for %3 in class GPR with hint $noreg
	Register: $r0 Cost: 0 BestCost: 4294967295
Assigning %3 to $r0
<< $r0 = LDR killed $r0 :: (dereferenceable load (s32) from %ir.a.addr)

>> STR %1:gpr, %4:gpr :: (store (s32) into %ir.b.addr)
Regs: R0=%3 R1=%4
Search register for %1 in class GPR with hint $noreg
	Preferred Register 1: $r1 occupied
	Register: $r0 Cost: 100 BestCost: 4294967295
	Register: $r1 Cost: 100 BestCost: 100
	Register: $r2 Cost: 0 BestCost: 80
Assigning %1 to $r2
<< STR killed $r2, $r1 :: (store (s32) into %ir.b.addr)

>> %4:gpr = ADD %stack.2.b.addr, %2:gpr
Regs: R0=%3 R1=%4 R2=%1
In def of %4 use existing assignment to $r1
Freeing $r1: %4
Search register for %2 in class GPR with hint $noreg
	Register: $r0 Cost: 100 BestCost: 4294967295
	Register: $r1 Cost: 0 BestCost: 100
Assigning %2 to $r1
<< $r1 = ADD %stack.2.b.addr, killed $r1

>> STR %0:gpr, %3:gpr :: (store (s32) into %ir.a.addr)
Regs: R0=%3 R1=%2 R2=%1
Search register for %0 in class GPR with hint $noreg
	Preferred Register 1: $r0 occupied
	Register: $r0 Cost: 100 BestCost: 4294967295
	Register: $r1 Cost: 100 BestCost: 80
	Register: $r2 Cost: 100 BestCost: 80
	Register: $r3 Cost: 0 BestCost: 80
Assigning %0 to $r3
<< STR killed $r3, $r0 :: (store (s32) into %ir.a.addr)

>> %3:gpr = ADD %stack.1.a.addr, %2:gpr
Regs: R0=%3 R1=%2 R2=%1 R3=%0
In def of %3 use existing assignment to $r0
Freeing $r0: %3
<< $r0 = ADD %stack.1.a.addr, $r1

>> %2:gpr = I_ALLOCA 0
Regs: R1=%2 R2=%1 R3=%0
In def of %2 use existing assignment to $r1
Freeing $r1: %2
<< $r1 = I_ALLOCA 0

>> %0:gpr = COPY $r0
Regs: R2=%1 R3=%0
In def of %0 use existing assignment to $r3
Freeing $r3: %0
<< $r3 = COPY killed $r0

>> %1:gpr = COPY $r1
Regs: R0[P] R2=%1
In def of %1 use existing assignment to $r2
Freeing $r2: %1
<< $r2 = COPY killed $r1
Begin Regs: R0[P] R1[P]
Loading live registers at begin of block.
bb.0.entry:
  successors: %bb.1, %bb.2
  liveins: $r0, $r1
  $r2 = COPY killed $r1
  $r3 = COPY killed $r0
  $r1 = I_ALLOCA 0
  $r0 = ADD %stack.1.a.addr, $r1
  STR killed $r3, $r0 :: (store (s32) into %ir.a.addr)
  $r1 = ADD %stack.2.b.addr, killed $r1
  STR killed $r2, $r1 :: (store (s32) into %ir.b.addr)
  $r0 = LDR killed $r0 :: (dereferenceable load (s32) from %ir.a.addr)
  $r1 = LDR killed $r1 :: (dereferenceable load (s32) from %ir.b.addr)
  $r0 = CMP killed $r0, killed $r1
  BRNCHZ killed $r0, %bb.2
  BRNCH %bb.1

Allocating bb.1.if.then:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %12:gpr = I_ALLOCA 0
  %13:gpr = ADD %stack.1.a.addr, %12:gpr
  %14:gpr = LDR killed %13:gpr :: (dereferenceable load (s32) from %ir.a.addr)
  %15:gpr = ADD %stack.0.retval, %12:gpr
  STR killed %14:gpr, killed %15:gpr :: (store (s32) into %ir.retval)
  BRNCH %bb.3

>> BRNCH %bb.3
Regs:
<< BRNCH %bb.3

>> STR killed %14:gpr, killed %15:gpr :: (store (s32) into %ir.retval)
Regs:
Search register for %14 in class GPR with hint $noreg
	Register: $r0 Cost: 0 BestCost: 4294967295
Assigning %14 to $r0
Search register for %15 in class GPR with hint $noreg
	Register: $r0 already used in instr.
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %15 to $r1
<< STR killed $r0, killed $r1 :: (store (s32) into %ir.retval)

>> %15:gpr = ADD %stack.0.retval, %12:gpr
Regs: R0=%14 R1=%15
In def of %15 use existing assignment to $r1
Freeing $r1: %15
Search register for %12 in class GPR with hint $noreg
	Register: $r0 Cost: 100 BestCost: 4294967295
	Register: $r1 Cost: 0 BestCost: 100
Assigning %12 to $r1
<< $r1 = ADD %stack.0.retval, killed $r1

>> %14:gpr = LDR killed %13:gpr :: (dereferenceable load (s32) from %ir.a.addr)
Regs: R0=%14 R1=%12
In def of %14 use existing assignment to $r0
Freeing $r0: %14
Search register for %13 in class GPR with hint $noreg
	Register: $r0 Cost: 0 BestCost: 4294967295
Assigning %13 to $r0
<< $r0 = LDR killed $r0 :: (dereferenceable load (s32) from %ir.a.addr)

>> %13:gpr = ADD %stack.1.a.addr, %12:gpr
Regs: R0=%13 R1=%12
In def of %13 use existing assignment to $r0
Freeing $r0: %13
<< $r0 = ADD %stack.1.a.addr, $r1

>> %12:gpr = I_ALLOCA 0
Regs: R1=%12
In def of %12 use existing assignment to $r1
Freeing $r1: %12
<< $r1 = I_ALLOCA 0
Begin Regs:
Loading live registers at begin of block.
bb.1.if.then:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  $r1 = I_ALLOCA 0
  $r0 = ADD %stack.1.a.addr, $r1
  $r0 = LDR killed $r0 :: (dereferenceable load (s32) from %ir.a.addr)
  $r1 = ADD %stack.0.retval, killed $r1
  STR killed $r0, killed $r1 :: (store (s32) into %ir.retval)
  BRNCH %bb.3

Allocating bb.2.if.else:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %8:gpr = I_ALLOCA 0
  %9:gpr = ADD %stack.2.b.addr, %8:gpr
  %10:gpr = LDR killed %9:gpr :: (dereferenceable load (s32) from %ir.b.addr)
  %11:gpr = ADD %stack.0.retval, %8:gpr
  STR killed %10:gpr, killed %11:gpr :: (store (s32) into %ir.retval)
  BRNCH %bb.3

>> BRNCH %bb.3
Regs:
<< BRNCH %bb.3

>> STR killed %10:gpr, killed %11:gpr :: (store (s32) into %ir.retval)
Regs:
Search register for %10 in class GPR with hint $noreg
	Register: $r0 Cost: 0 BestCost: 4294967295
Assigning %10 to $r0
Search register for %11 in class GPR with hint $noreg
	Register: $r0 already used in instr.
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %11 to $r1
<< STR killed $r0, killed $r1 :: (store (s32) into %ir.retval)

>> %11:gpr = ADD %stack.0.retval, %8:gpr
Regs: R0=%10 R1=%11
In def of %11 use existing assignment to $r1
Freeing $r1: %11
Search register for %8 in class GPR with hint $noreg
	Register: $r0 Cost: 100 BestCost: 4294967295
	Register: $r1 Cost: 0 BestCost: 100
Assigning %8 to $r1
<< $r1 = ADD %stack.0.retval, killed $r1

>> %10:gpr = LDR killed %9:gpr :: (dereferenceable load (s32) from %ir.b.addr)
Regs: R0=%10 R1=%8
In def of %10 use existing assignment to $r0
Freeing $r0: %10
Search register for %9 in class GPR with hint $noreg
	Register: $r0 Cost: 0 BestCost: 4294967295
Assigning %9 to $r0
<< $r0 = LDR killed $r0 :: (dereferenceable load (s32) from %ir.b.addr)

>> %9:gpr = ADD %stack.2.b.addr, %8:gpr
Regs: R0=%9 R1=%8
In def of %9 use existing assignment to $r0
Freeing $r0: %9
<< $r0 = ADD %stack.2.b.addr, $r1

>> %8:gpr = I_ALLOCA 0
Regs: R1=%8
In def of %8 use existing assignment to $r1
Freeing $r1: %8
<< $r1 = I_ALLOCA 0
Begin Regs:
Loading live registers at begin of block.
bb.2.if.else:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  $r1 = I_ALLOCA 0
  $r0 = ADD %stack.2.b.addr, $r1
  $r0 = LDR killed $r0 :: (dereferenceable load (s32) from %ir.b.addr)
  $r1 = ADD %stack.0.retval, killed $r1
  STR killed $r0, killed $r1 :: (store (s32) into %ir.retval)
  BRNCH %bb.3

Allocating bb.3.return:
; predecessors: %bb.2, %bb.1

  %16:gpr = I_ALLOCA 0
  %17:gpr = ADD %stack.0.retval, killed %16:gpr
  %18:gpr = LDR killed %17:gpr :: (dereferenceable load (s32) from %ir.retval)
  $r0 = COPY %18:gpr
  PseudoRET implicit $r0

>> PseudoRET implicit $r0
Regs:
<< PseudoRET implicit killed $r0

>> $r0 = COPY %18:gpr
Regs: R0[P]
Freeing $r0:
Search register for %18 in class GPR with hint $r0
	Preferred Register 1: $r0
Assigning %18 to $r0
<< $r0 = COPY killed $r0
Mark identity copy for removal

>> %18:gpr = LDR killed %17:gpr :: (dereferenceable load (s32) from %ir.retval)
Regs: R0=%18
In def of %18 use existing assignment to $r0
Freeing $r0: %18
Search register for %17 in class GPR with hint $noreg
	Register: $r0 Cost: 0 BestCost: 4294967295
Assigning %17 to $r0
<< $r0 = LDR killed $r0 :: (dereferenceable load (s32) from %ir.retval)

>> %17:gpr = ADD %stack.0.retval, killed %16:gpr
Regs: R0=%17
In def of %17 use existing assignment to $r0
Freeing $r0: %17
Search register for %16 in class GPR with hint $noreg
	Register: $r0 Cost: 0 BestCost: 4294967295
Assigning %16 to $r0
<< $r0 = ADD %stack.0.retval, killed $r0

>> %16:gpr = I_ALLOCA 0
Regs: R0=%16
In def of %16 use existing assignment to $r0
Freeing $r0: %16
<< $r0 = I_ALLOCA 0
Begin Regs:
Loading live registers at begin of block.
bb.3.return:
; predecessors: %bb.2, %bb.1

  $r0 = I_ALLOCA 0
  $r0 = ADD %stack.0.retval, killed $r0
  $r0 = LDR killed $r0 :: (dereferenceable load (s32) from %ir.retval)
  PseudoRET implicit killed $r0
Skipping pass 'Fixup Statepoint Caller Saved' on function _Z6branchii
alloc FI(0) at SP[-4]
alloc FI(1) at SP[-8]
alloc FI(2) at SP[-12]
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: _Z6branchii

Debug Range Extension: _Z6branchii
