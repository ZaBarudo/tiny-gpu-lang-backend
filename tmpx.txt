Args: llc -march=tinygpu -O0 index9.ll -debug -view-isel-dags -o index.S 

Features:
CPU:generic
TuneCPU:generic

[SafeStack] Function: _Z13callGetNumberv
[SafeStack]     safestack is not requested for this function
Skipping pass 'CPU0 DAG->DAG Pattern Instruction Selection' on function _Z13callGetNumberv
	FastISel is enabled



=== _Z13callGetNumberv
Enabling fast-isel
Creating constant: t2: i32 = Constant<0>
Creating new node: t3: i32 = undef
Creating new node: t4: i32,ch = load<(dereferenceable load (s32) from @total)> t0, GlobalAddress:i32<ptr @total> 0, undef:i32
Creating constant: t5: i32 = Constant<3>
Creating new node: t6: i32 = mul nsw t4, Constant:i32<3>
Creating new node: t8: ch = store<(store (s32) into %ir.c)> t4:1, t6, FrameIndex:i32<0>, undef:i32
Creating new node: t9: ch = TinyGPUISD::Ret t8

Initial selection DAG: %bb.0 '_Z13callGetNumberv:entry'
SelectionDAG has 10 nodes:
  t2: i32 = Constant<0>
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from @total)> t0, GlobalAddress:i32<ptr @total> 0, undef:i32
      t6: i32 = mul nsw t4, Constant:i32<3>
    t8: ch = store<(store (s32) into %ir.c)> t4:1, t6, FrameIndex:i32<0>, undef:i32
  t9: ch = TinyGPUISD::Ret t8



Combining: t9: ch = TinyGPUISD::Ret t8

Combining: t8: ch = store<(store (s32) into %ir.c)> t4:1, t6, FrameIndex:i32<0>, undef:i32

Combining: t7: i32 = FrameIndex<0>

Combining: t6: i32 = mul nsw t4, Constant:i32<3>

Combining: t5: i32 = Constant<3>

Combining: t4: i32,ch = load<(dereferenceable load (s32) from @total)> t0, GlobalAddress:i32<ptr @total> 0, undef:i32

Combining: t3: i32 = undef

Combining: t1: i32 = GlobalAddress<ptr @total> 0

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.0 '_Z13callGetNumberv:entry'
SelectionDAG has 9 nodes:
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from @total)> t0, GlobalAddress:i32<ptr @total> 0, undef:i32
      t6: i32 = mul nsw t4, Constant:i32<3>
    t8: ch = store<(store (s32) into %ir.c)> t4:1, t6, FrameIndex:i32<0>, undef:i32
  t9: ch = TinyGPUISD::Ret t8



Legalizing node: t7: i32 = FrameIndex<0>
Analyzing result type: i32
Legal result type
Legally typed node: t7: i32 = FrameIndex<0>

Legalizing node: t5: i32 = Constant<3>
Analyzing result type: i32
Legal result type
Legally typed node: t5: i32 = Constant<3>

Legalizing node: t3: i32 = undef
Analyzing result type: i32
Legal result type
Legally typed node: t3: i32 = undef

Legalizing node: t1: i32 = GlobalAddress<ptr @total> 0
Analyzing result type: i32
Legal result type
Legally typed node: t1: i32 = GlobalAddress<ptr @total> 0

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: i32,ch = load<(dereferenceable load (s32) from @total)> t0, GlobalAddress:i32<ptr @total> 0, undef:i32
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i32 = GlobalAddress<ptr @total> 0
Legal operand
Analyzing operand: t3: i32 = undef
Legal operand
Legally typed node: t4: i32,ch = load<(dereferenceable load (s32) from @total)> t0, GlobalAddress:i32<ptr @total> 0, undef:i32

Legalizing node: t6: i32 = mul nsw t4, Constant:i32<3>
Analyzing result type: i32
Legal result type
Analyzing operand: t4: i32,ch = load<(dereferenceable load (s32) from @total)> t0, GlobalAddress:i32<ptr @total> 0, undef:i32
Legal operand
Analyzing operand: t5: i32 = Constant<3>
Legal operand
Legally typed node: t6: i32 = mul nsw t4, Constant:i32<3>

Legalizing node: t8: ch = store<(store (s32) into %ir.c)> t4:1, t6, FrameIndex:i32<0>, undef:i32
Analyzing result type: ch
Legal result type
Analyzing operand: t4: i32,ch = load<(dereferenceable load (s32) from @total)> t0, GlobalAddress:i32<ptr @total> 0, undef:i32
Legal operand
Analyzing operand: t6: i32 = mul nsw t4, Constant:i32<3>
Legal operand
Analyzing operand: t7: i32 = FrameIndex<0>
Legal operand
Analyzing operand: t3: i32 = undef
Legal operand
Legally typed node: t8: ch = store<(store (s32) into %ir.c)> t4:1, t6, FrameIndex:i32<0>, undef:i32

Legalizing node: t9: ch = TinyGPUISD::Ret t8
Analyzing result type: ch
Legal result type
Analyzing operand: t8: ch = store<(store (s32) into %ir.c)> t4:1, t6, FrameIndex:i32<0>, undef:i32
Legal operand
Legally typed node: t9: ch = TinyGPUISD::Ret t8

Legalizing node: t65535: ch = handlenode t9
Analyzing result type: ch
Legal result type
Analyzing operand: t9: ch = TinyGPUISD::Ret t8
Legal operand
Legally typed node: t65535: ch = handlenode t9

Type-legalized selection DAG: %bb.0 '_Z13callGetNumberv:entry'
SelectionDAG has 9 nodes:
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from @total)> t0, GlobalAddress:i32<ptr @total> 0, undef:i32
      t6: i32 = mul nsw t4, Constant:i32<3>
    t8: ch = store<(store (s32) into %ir.c)> t4:1, t6, FrameIndex:i32<0>, undef:i32
  t9: ch = TinyGPUISD::Ret t8



Legalizing: t9: ch = TinyGPUISD::Ret t8
Legal node: nothing to do

Legalizing: t8: ch = store<(store (s32) into %ir.c)> t4:1, t6, FrameIndex:i32<0>, undef:i32
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t6: i32 = mul nsw t4, Constant:i32<3>
Legal node: nothing to do

Legalizing: t4: i32,ch = load<(dereferenceable load (s32) from @total)> t0, GlobalAddress:i32<ptr @total> 0, undef:i32
Legalizing non-extending load operation

Legalizing: t7: i32 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t5: i32 = Constant<3>
Legal node: nothing to do

Legalizing: t3: i32 = undef
Legal node: nothing to do

Legalizing: t1: i32 = GlobalAddress<ptr @total> 0
Trying custom legalization
Successfully custom legalized node
 ... replacing: t1: i32 = GlobalAddress<ptr @total> 0
     with:      t10: i32 = TargetGlobalAddress<ptr @total> 0

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t10: i32 = TargetGlobalAddress<ptr @total> 0
Legal node: nothing to do

Legalized selection DAG: %bb.0 '_Z13callGetNumberv:entry'
SelectionDAG has 9 nodes:
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from @total)> t0, TargetGlobalAddress:i32<ptr @total> 0, undef:i32
      t6: i32 = mul nsw t4, Constant:i32<3>
    t8: ch = store<(store (s32) into %ir.c)> t4:1, t6, FrameIndex:i32<0>, undef:i32
  t9: ch = TinyGPUISD::Ret t8



Legalizing: t10: i32 = TargetGlobalAddress<ptr @total> 0
Legal node: nothing to do

Combining: t10: i32 = TargetGlobalAddress<ptr @total> 0

Legalizing: t9: ch = TinyGPUISD::Ret t8
Legal node: nothing to do

Combining: t9: ch = TinyGPUISD::Ret t8

Legalizing: t8: ch = store<(store (s32) into %ir.c)> t4:1, t6, FrameIndex:i32<0>, undef:i32
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t8: ch = store<(store (s32) into %ir.c)> t4:1, t6, FrameIndex:i32<0>, undef:i32

Legalizing: t6: i32 = mul nsw t4, Constant:i32<3>
Legal node: nothing to do

Combining: t6: i32 = mul nsw t4, Constant:i32<3>

Legalizing: t4: i32,ch = load<(dereferenceable load (s32) from @total)> t0, TargetGlobalAddress:i32<ptr @total> 0, undef:i32
Legalizing non-extending load operation

Combining: t4: i32,ch = load<(dereferenceable load (s32) from @total)> t0, TargetGlobalAddress:i32<ptr @total> 0, undef:i32

Legalizing: t7: i32 = FrameIndex<0>
Legal node: nothing to do

Combining: t7: i32 = FrameIndex<0>

Legalizing: t5: i32 = Constant<3>
Legal node: nothing to do

Combining: t5: i32 = Constant<3>

Legalizing: t3: i32 = undef
Legal node: nothing to do

Combining: t3: i32 = undef

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.0 '_Z13callGetNumberv:entry'
SelectionDAG has 9 nodes:
    t0: ch,glue = EntryToken
  t4: i32,ch = load<(dereferenceable load (s32) from @total)> t0, TargetGlobalAddress:i32<ptr @total> 0, undef:i32
      t6: i32 = mul nsw t4, Constant:i32<3>
    t8: ch = store<(store (s32) into %ir.c)> t4:1, t6, FrameIndex:i32<0>, undef:i32
  t9: ch = TinyGPUISD::Ret t8


Writing '/tmp/dag._Z13callGetNumberv-d2b3d6.dot'...  done. 
Trying 'xdg-open' program... Remember to erase graph file: /tmp/dag._Z13callGetNumberv-d2b3d6.dot
===== Instruction selection begins: %bb.0 'entry'

ISEL: Starting selection on root node: t9: ch = TinyGPUISD::Ret t8
ISEL: Starting pattern match
  Morphed node: t9: ch = PseudoRET t8
ISEL: Match complete!

ISEL: Starting selection on root node: t8: ch = store<(store (s32) into %ir.c)> t4:1, t6, FrameIndex:i32<0>, undef:i32
ISEL: Starting pattern match
  Initial Opcode index to 53
  Match failed at index 59
  Continuing at 77
  Morphed node: t8: ch = STR<Mem:(store (s32) into %ir.c)> t6, FrameIndex:i32<0>, t4:1
ISEL: Match complete!

ISEL: Starting selection on root node: t6: i32 = mul nsw t4, Constant:i32<3>
ISEL: Starting pattern match
  Initial Opcode index to 167
Creating constant: t11: i32 = TargetConstant<3>
Creating new machine node: t12: i32 = I_ALLOCA TargetConstant:i32<3>
  Created node: t12: i32 = I_ALLOCA TargetConstant:i32<3>
  Morphed node: t6: i32 = MUL nsw t4, t12
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i32,ch = load<(dereferenceable load (s32) from @total)> t0, TargetGlobalAddress:i32<ptr @total> 0, undef:i32
ISEL: Starting pattern match
  Initial Opcode index to 254
  Morphed node: t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from @total)> TargetGlobalAddress:i32<ptr @total> 0, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t10: i32 = TargetGlobalAddress<ptr @total> 0

ISEL: Starting selection on root node: t7: i32 = FrameIndex<0>
ISEL: Starting pattern match
  Initial Opcode index to 517
Creating constant: t14: i32 = TargetConstant<0>
Creating new machine node: t15: i32 = I_ALLOCA TargetConstant:i32<0>
  Created node: t15: i32 = I_ALLOCA TargetConstant:i32<0>
  Morphed node: t7: i32 = ADD TargetFrameIndex:i32<0>, t15
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:

Selected selection DAG: %bb.0 '_Z13callGetNumberv:entry'
SelectionDAG has 12 nodes:
    t0: ch,glue = EntryToken
  t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from @total)> TargetGlobalAddress:i32<ptr @total> 0, t0
        t12: i32 = I_ALLOCA TargetConstant:i32<3>
      t6: i32 = MUL nsw t4, t12
        t15: i32 = I_ALLOCA TargetConstant:i32<0>
      t7: i32 = ADD TargetFrameIndex:i32<0>, t15
    t8: ch = STR<Mem:(store (s32) into %ir.c)> t6, t7, t4:1
  t9: ch = PseudoRET t8


********** List Scheduling %bb.0 'entry' **********
SU(0): t9: ch = PseudoRET t8

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t8: ch = STR<Mem:(store (s32) into %ir.c)> t6, t7, t4:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(5): Data Latency=1
    SU(3): Data Latency=1
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from @total)> TargetGlobalAddress:i32<ptr @total> 0, t0

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(1): Ord  Latency=1 Barrier
    SU(5): Data Latency=1
SU(3): t7: i32 = ADD TargetFrameIndex:i32<0>, t15

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(4): t15: i32 = I_ALLOCA TargetConstant:i32<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(3): Data Latency=1
SU(5): t6: i32 = MUL nsw t4, t12

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(2): Data Latency=1
    SU(6): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(6): t12: i32 = I_ALLOCA TargetConstant:i32<3>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(5): Data Latency=1

Examining Available:
Height 0: SU(0): t9: ch = PseudoRET t8


*** Scheduling [0]: SU(0): t9: ch = PseudoRET t8


Examining Available:
Height 1: SU(1): t8: ch = STR<Mem:(store (s32) into %ir.c)> t6, t7, t4:1


*** Scheduling [1]: SU(1): t8: ch = STR<Mem:(store (s32) into %ir.c)> t6, t7, t4:1


Examining Available:
Height 2: SU(3): t7: i32 = ADD TargetFrameIndex:i32<0>, t15

Height 2: SU(5): t6: i32 = MUL nsw t4, t12


*** Scheduling [2]: SU(3): t7: i32 = ADD TargetFrameIndex:i32<0>, t15


Examining Available:
Height 3: SU(4): t15: i32 = I_ALLOCA TargetConstant:i32<0>

Height 2: SU(5): t6: i32 = MUL nsw t4, t12


*** Scheduling [3]: SU(4): t15: i32 = I_ALLOCA TargetConstant:i32<0>


Examining Available:
Height 2: SU(5): t6: i32 = MUL nsw t4, t12


*** Scheduling [4]: SU(5): t6: i32 = MUL nsw t4, t12


Examining Available:
Height 5: SU(6): t12: i32 = I_ALLOCA TargetConstant:i32<3>

Height 5: SU(2): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from @total)> TargetGlobalAddress:i32<ptr @total> 0, t0


*** Scheduling [5]: SU(6): t12: i32 = I_ALLOCA TargetConstant:i32<3>


Examining Available:
Height 5: SU(2): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from @total)> TargetGlobalAddress:i32<ptr @total> 0, t0


*** Scheduling [6]: SU(2): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from @total)> TargetGlobalAddress:i32<ptr @total> 0, t0

*** Final schedule ***
SU(2): t4: i32,ch = LDR<Mem:(dereferenceable load (s32) from @total)> TargetGlobalAddress:i32<ptr @total> 0, t0

SU(6): t12: i32 = I_ALLOCA TargetConstant:i32<3>

SU(5): t6: i32 = MUL nsw t4, t12

SU(4): t15: i32 = I_ALLOCA TargetConstant:i32<0>

SU(3): t7: i32 = ADD TargetFrameIndex:i32<0>, t15

SU(1): t8: ch = STR<Mem:(store (s32) into %ir.c)> t6, t7, t4:1

SU(0): t9: ch = PseudoRET t8


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function _Z13callGetNumberv: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP]

bb.0.entry:
  %0:gpr = LDR @total :: (dereferenceable load (s32) from @total)
  %1:gpr = I_ALLOCA 3
  %2:gpr = nsw MUL killed %0:gpr, killed %1:gpr
  %3:gpr = I_ALLOCA 0
  %4:gpr = ADD %stack.0.c, killed %3:gpr
  STR killed %2:gpr, killed %4:gpr :: (store (s32) into %ir.c)
  PseudoRET

# End machine code for function _Z13callGetNumberv.

Skipping pass 'Two-Address instruction pass' on function _Z13callGetNumberv
********** REWRITING TWO-ADDR INSTRS **********
********** Function: _Z13callGetNumberv
********** FAST REGISTER ALLOCATION **********
********** Function: _Z13callGetNumberv

Allocating bb.0.entry:
  %0:gpr = LDR @total :: (dereferenceable load (s32) from @total)
  %1:gpr = I_ALLOCA 3
  %2:gpr = nsw MUL killed %0:gpr, killed %1:gpr
  %3:gpr = I_ALLOCA 0
  %4:gpr = ADD %stack.0.c, killed %3:gpr
  STR killed %2:gpr, killed %4:gpr :: (store (s32) into %ir.c)
  PseudoRET

>> PseudoRET
Regs:
<< PseudoRET

>> STR killed %2:gpr, killed %4:gpr :: (store (s32) into %ir.c)
Regs:
Search register for %2 in class GPR with hint $noreg
AllocationOrder(GPR) = [ $r0 $r1 $r2 $r3 $r4 $r5 $r6 $r7 $r10 $r8 $r9 ]
	Register: $r0 Cost: 0 BestCost: 4294967295
Assigning %2 to $r0
Search register for %4 in class GPR with hint $noreg
	Register: $r0 already used in instr.
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %4 to $r1
<< STR killed $r0, killed $r1 :: (store (s32) into %ir.c)

>> %4:gpr = ADD %stack.0.c, killed %3:gpr
Regs: R0=%2 R1=%4
In def of %4 use existing assignment to $r1
Freeing $r1: %4
Search register for %3 in class GPR with hint $noreg
	Register: $r0 Cost: 100 BestCost: 4294967295
	Register: $r1 Cost: 0 BestCost: 100
Assigning %3 to $r1
<< $r1 = ADD %stack.0.c, killed $r1

>> %3:gpr = I_ALLOCA 0
Regs: R0=%2 R1=%3
In def of %3 use existing assignment to $r1
Freeing $r1: %3
<< $r1 = I_ALLOCA 0

>> %2:gpr = nsw MUL killed %0:gpr, killed %1:gpr
Regs: R0=%2
In def of %2 use existing assignment to $r0
Freeing $r0: %2
Search register for %0 in class GPR with hint $noreg
	Register: $r0 Cost: 0 BestCost: 4294967295
Assigning %0 to $r0
Search register for %1 in class GPR with hint $noreg
	Register: $r0 already used in instr.
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %1 to $r1
<< $r0 = nsw MUL killed $r0, killed $r1

>> %1:gpr = I_ALLOCA 3
Regs: R0=%0 R1=%1
In def of %1 use existing assignment to $r1
Freeing $r1: %1
<< $r1 = I_ALLOCA 3

>> %0:gpr = LDR @total :: (dereferenceable load (s32) from @total)
Regs: R0=%0
In def of %0 use existing assignment to $r0
Freeing $r0: %0
<< $r0 = LDR @total :: (dereferenceable load (s32) from @total)
Begin Regs:
Loading live registers at begin of block.
bb.0.entry:
  $r0 = LDR @total :: (dereferenceable load (s32) from @total)
  $r1 = I_ALLOCA 3
  $r0 = nsw MUL killed $r0, killed $r1
  $r1 = I_ALLOCA 0
  $r1 = ADD %stack.0.c, killed $r1
  STR killed $r0, killed $r1 :: (store (s32) into %ir.c)
  PseudoRET
Skipping pass 'Fixup Statepoint Caller Saved' on function _Z13callGetNumberv
alloc FI(0) at SP[-4]
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: _Z13callGetNumberv

Debug Range Extension: _Z13callGetNumberv
