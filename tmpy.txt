Args: llc -march=tinygpu -O0 index8.ll -debug -view-isel-dags -o index.S 

Features:
CPU:generic
TuneCPU:generic

[SafeStack] Function: _Z9getNumberii
[SafeStack]     safestack is not requested for this function
Skipping pass 'CPU0 DAG->DAG Pattern Instruction Selection' on function _Z9getNumberii
	FastISel is enabled



=== _Z9getNumberii
Enabling fast-isel
Found argument copy elision candidate:   %x.addr = alloca i32, align 4
Found argument copy elision candidate:   %y.addr = alloca i32, align 4
Creating new node: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Creating new node: t4: i32,ch = CopyFromReg t0, Register:i32 %1
Creating constant: t6: i32 = Constant<0>
Creating new node: t7: i32 = undef
Creating new node: t8: ch = store<(store (s32) into %ir.x.addr)> t0, t2, FrameIndex:i32<0>, undef:i32
Creating new node: t10: ch = store<(store (s32) into %ir.y.addr)> t8, t4, FrameIndex:i32<1>, undef:i32
Creating new node: t11: i32,ch = load<(dereferenceable load (s32) from %ir.x.addr)> t10, FrameIndex:i32<0>, undef:i32
Creating new node: t12: i32,ch = load<(dereferenceable load (s32) from %ir.y.addr)> t10, FrameIndex:i32<1>, undef:i32
Creating new node: t13: i32 = add nsw t11, t12
Creating new node: t15: ch,glue = CopyToReg t10, Register:i32 $r0, t13
Creating new node: t16: ch = TinyGPUISD::Ret t15, Register:i32 $r0, t15:1

Initial selection DAG: %bb.0 '_Z9getNumberii:entry'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
  t6: i32 = Constant<0>
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t8: ch = store<(store (s32) into %ir.x.addr)> t0, t2, FrameIndex:i32<0>, undef:i32
    t4: i32,ch = CopyFromReg t0, Register:i32 %1
  t10: ch = store<(store (s32) into %ir.y.addr)> t8, t4, FrameIndex:i32<1>, undef:i32
      t11: i32,ch = load<(dereferenceable load (s32) from %ir.x.addr)> t10, FrameIndex:i32<0>, undef:i32
      t12: i32,ch = load<(dereferenceable load (s32) from %ir.y.addr)> t10, FrameIndex:i32<1>, undef:i32
    t13: i32 = add nsw t11, t12
  t15: ch,glue = CopyToReg t10, Register:i32 $r0, t13
  t16: ch = TinyGPUISD::Ret t15, Register:i32 $r0, t15:1



Combining: t16: ch = TinyGPUISD::Ret t15, Register:i32 $r0, t15:1

Combining: t15: ch,glue = CopyToReg t10, Register:i32 $r0, t13

Combining: t14: i32 = Register $r0

Combining: t13: i32 = add nsw t11, t12

Combining: t12: i32,ch = load<(dereferenceable load (s32) from %ir.y.addr)> t10, FrameIndex:i32<1>, undef:i32

Combining: t11: i32,ch = load<(dereferenceable load (s32) from %ir.x.addr)> t10, FrameIndex:i32<0>, undef:i32

Combining: t10: ch = store<(store (s32) into %ir.y.addr)> t8, t4, FrameIndex:i32<1>, undef:i32

Combining: t9: i32 = FrameIndex<1>

Combining: t8: ch = store<(store (s32) into %ir.x.addr)> t0, t2, FrameIndex:i32<0>, undef:i32

Combining: t7: i32 = undef

Combining: t5: i32 = FrameIndex<0>

Combining: t4: i32,ch = CopyFromReg t0, Register:i32 %1

Combining: t3: i32 = Register %1

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %0

Combining: t1: i32 = Register %0

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.0 '_Z9getNumberii:entry'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t8: ch = store<(store (s32) into %ir.x.addr)> t0, t2, FrameIndex:i32<0>, undef:i32
    t4: i32,ch = CopyFromReg t0, Register:i32 %1
  t10: ch = store<(store (s32) into %ir.y.addr)> t8, t4, FrameIndex:i32<1>, undef:i32
      t11: i32,ch = load<(dereferenceable load (s32) from %ir.x.addr)> t10, FrameIndex:i32<0>, undef:i32
      t12: i32,ch = load<(dereferenceable load (s32) from %ir.y.addr)> t10, FrameIndex:i32<1>, undef:i32
    t13: i32 = add nsw t11, t12
  t15: ch,glue = CopyToReg t10, Register:i32 $r0, t13
  t16: ch = TinyGPUISD::Ret t15, Register:i32 $r0, t15:1



Legalizing node: t14: i32 = Register $r0
Ignoring node results
Legally typed node: t14: i32 = Register $r0

Legalizing node: t9: i32 = FrameIndex<1>
Analyzing result type: i32
Legal result type
Legally typed node: t9: i32 = FrameIndex<1>

Legalizing node: t7: i32 = undef
Analyzing result type: i32
Legal result type
Legally typed node: t7: i32 = undef

Legalizing node: t5: i32 = FrameIndex<0>
Analyzing result type: i32
Legal result type
Legally typed node: t5: i32 = FrameIndex<0>

Legalizing node: t3: i32 = Register %1
Ignoring node results
Legally typed node: t3: i32 = Register %1

Legalizing node: t1: i32 = Register %0
Ignoring node results
Legally typed node: t1: i32 = Register %0

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i32,ch = CopyFromReg t0, Register:i32 %0

Legalizing node: t8: ch = store<(store (s32) into %ir.x.addr)> t0, t2, FrameIndex:i32<0>, undef:i32
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Legal operand
Analyzing operand: t5: i32 = FrameIndex<0>
Legal operand
Analyzing operand: t7: i32 = undef
Legal operand
Legally typed node: t8: ch = store<(store (s32) into %ir.x.addr)> t0, t2, FrameIndex:i32<0>, undef:i32

Legalizing node: t4: i32,ch = CopyFromReg t0, Register:i32 %1
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t4: i32,ch = CopyFromReg t0, Register:i32 %1

Legalizing node: t10: ch = store<(store (s32) into %ir.y.addr)> t8, t4, FrameIndex:i32<1>, undef:i32
Analyzing result type: ch
Legal result type
Analyzing operand: t8: ch = store<(store (s32) into %ir.x.addr)> t0, t2, FrameIndex:i32<0>, undef:i32
Legal operand
Analyzing operand: t4: i32,ch = CopyFromReg t0, Register:i32 %1
Legal operand
Analyzing operand: t9: i32 = FrameIndex<1>
Legal operand
Analyzing operand: t7: i32 = undef
Legal operand
Legally typed node: t10: ch = store<(store (s32) into %ir.y.addr)> t8, t4, FrameIndex:i32<1>, undef:i32

Legalizing node: t11: i32,ch = load<(dereferenceable load (s32) from %ir.x.addr)> t10, FrameIndex:i32<0>, undef:i32
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = store<(store (s32) into %ir.y.addr)> t8, t4, FrameIndex:i32<1>, undef:i32
Legal operand
Analyzing operand: t5: i32 = FrameIndex<0>
Legal operand
Analyzing operand: t7: i32 = undef
Legal operand
Legally typed node: t11: i32,ch = load<(dereferenceable load (s32) from %ir.x.addr)> t10, FrameIndex:i32<0>, undef:i32

Legalizing node: t12: i32,ch = load<(dereferenceable load (s32) from %ir.y.addr)> t10, FrameIndex:i32<1>, undef:i32
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = store<(store (s32) into %ir.y.addr)> t8, t4, FrameIndex:i32<1>, undef:i32
Legal operand
Analyzing operand: t9: i32 = FrameIndex<1>
Legal operand
Analyzing operand: t7: i32 = undef
Legal operand
Legally typed node: t12: i32,ch = load<(dereferenceable load (s32) from %ir.y.addr)> t10, FrameIndex:i32<1>, undef:i32

Legalizing node: t13: i32 = add nsw t11, t12
Analyzing result type: i32
Legal result type
Analyzing operand: t11: i32,ch = load<(dereferenceable load (s32) from %ir.x.addr)> t10, FrameIndex:i32<0>, undef:i32
Legal operand
Analyzing operand: t12: i32,ch = load<(dereferenceable load (s32) from %ir.y.addr)> t10, FrameIndex:i32<1>, undef:i32
Legal operand
Legally typed node: t13: i32 = add nsw t11, t12

Legalizing node: t15: ch,glue = CopyToReg t10, Register:i32 $r0, t13
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t10: ch = store<(store (s32) into %ir.y.addr)> t8, t4, FrameIndex:i32<1>, undef:i32
Legal operand
Analyzing operand: t13: i32 = add nsw t11, t12
Legal operand
Legally typed node: t15: ch,glue = CopyToReg t10, Register:i32 $r0, t13

Legalizing node: t16: ch = TinyGPUISD::Ret t15, Register:i32 $r0, t15:1
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch,glue = CopyToReg t10, Register:i32 $r0, t13
Legal operand
Analyzing operand: t15: ch,glue = CopyToReg t10, Register:i32 $r0, t13
Legal operand
Legally typed node: t16: ch = TinyGPUISD::Ret t15, Register:i32 $r0, t15:1

Legalizing node: t65535: ch = handlenode t16
Analyzing result type: ch
Legal result type
Analyzing operand: t16: ch = TinyGPUISD::Ret t15, Register:i32 $r0, t15:1
Legal operand
Legally typed node: t65535: ch = handlenode t16

Type-legalized selection DAG: %bb.0 '_Z9getNumberii:entry'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t8: ch = store<(store (s32) into %ir.x.addr)> t0, t2, FrameIndex:i32<0>, undef:i32
    t4: i32,ch = CopyFromReg t0, Register:i32 %1
  t10: ch = store<(store (s32) into %ir.y.addr)> t8, t4, FrameIndex:i32<1>, undef:i32
      t11: i32,ch = load<(dereferenceable load (s32) from %ir.x.addr)> t10, FrameIndex:i32<0>, undef:i32
      t12: i32,ch = load<(dereferenceable load (s32) from %ir.y.addr)> t10, FrameIndex:i32<1>, undef:i32
    t13: i32 = add nsw t11, t12
  t15: ch,glue = CopyToReg t10, Register:i32 $r0, t13
  t16: ch = TinyGPUISD::Ret t15, Register:i32 $r0, t15:1



Legalizing: t16: ch = TinyGPUISD::Ret t15, Register:i32 $r0, t15:1
Legal node: nothing to do

Legalizing: t15: ch,glue = CopyToReg t10, Register:i32 $r0, t13
Legal node: nothing to do

Legalizing: t13: i32 = add nsw t11, t12
Legal node: nothing to do

Legalizing: t11: i32,ch = load<(dereferenceable load (s32) from %ir.x.addr)> t10, FrameIndex:i32<0>, undef:i32
Legalizing non-extending load operation

Legalizing: t12: i32,ch = load<(dereferenceable load (s32) from %ir.y.addr)> t10, FrameIndex:i32<1>, undef:i32
Legalizing non-extending load operation

Legalizing: t10: ch = store<(store (s32) into %ir.y.addr)> t8, t4, FrameIndex:i32<1>, undef:i32
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t8: ch = store<(store (s32) into %ir.x.addr)> t0, t2, FrameIndex:i32<0>, undef:i32
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t4: i32,ch = CopyFromReg t0, Register:i32 %1
Legal node: nothing to do

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Legal node: nothing to do

Legalizing: t14: i32 = Register $r0

Legalizing: t9: i32 = FrameIndex<1>
Legal node: nothing to do

Legalizing: t7: i32 = undef
Legal node: nothing to do

Legalizing: t5: i32 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t3: i32 = Register %1

Legalizing: t1: i32 = Register %0

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.0 '_Z9getNumberii:entry'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t8: ch = store<(store (s32) into %ir.x.addr)> t0, t2, FrameIndex:i32<0>, undef:i32
    t4: i32,ch = CopyFromReg t0, Register:i32 %1
  t10: ch = store<(store (s32) into %ir.y.addr)> t8, t4, FrameIndex:i32<1>, undef:i32
      t11: i32,ch = load<(dereferenceable load (s32) from %ir.x.addr)> t10, FrameIndex:i32<0>, undef:i32
      t12: i32,ch = load<(dereferenceable load (s32) from %ir.y.addr)> t10, FrameIndex:i32<1>, undef:i32
    t13: i32 = add nsw t11, t12
  t15: ch,glue = CopyToReg t10, Register:i32 $r0, t13
  t16: ch = TinyGPUISD::Ret t15, Register:i32 $r0, t15:1



Legalizing: t16: ch = TinyGPUISD::Ret t15, Register:i32 $r0, t15:1
Legal node: nothing to do

Combining: t16: ch = TinyGPUISD::Ret t15, Register:i32 $r0, t15:1

Legalizing: t15: ch,glue = CopyToReg t10, Register:i32 $r0, t13
Legal node: nothing to do

Combining: t15: ch,glue = CopyToReg t10, Register:i32 $r0, t13

Legalizing: t13: i32 = add nsw t11, t12
Legal node: nothing to do

Combining: t13: i32 = add nsw t11, t12

Legalizing: t11: i32,ch = load<(dereferenceable load (s32) from %ir.x.addr)> t10, FrameIndex:i32<0>, undef:i32
Legalizing non-extending load operation

Combining: t11: i32,ch = load<(dereferenceable load (s32) from %ir.x.addr)> t10, FrameIndex:i32<0>, undef:i32

Legalizing: t12: i32,ch = load<(dereferenceable load (s32) from %ir.y.addr)> t10, FrameIndex:i32<1>, undef:i32
Legalizing non-extending load operation

Combining: t12: i32,ch = load<(dereferenceable load (s32) from %ir.y.addr)> t10, FrameIndex:i32<1>, undef:i32

Legalizing: t10: ch = store<(store (s32) into %ir.y.addr)> t8, t4, FrameIndex:i32<1>, undef:i32
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t10: ch = store<(store (s32) into %ir.y.addr)> t8, t4, FrameIndex:i32<1>, undef:i32

Legalizing: t8: ch = store<(store (s32) into %ir.x.addr)> t0, t2, FrameIndex:i32<0>, undef:i32
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t8: ch = store<(store (s32) into %ir.x.addr)> t0, t2, FrameIndex:i32<0>, undef:i32

Legalizing: t4: i32,ch = CopyFromReg t0, Register:i32 %1
Legal node: nothing to do

Combining: t4: i32,ch = CopyFromReg t0, Register:i32 %1

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Legal node: nothing to do

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %0

Legalizing: t14: i32 = Register $r0

Combining: t14: i32 = Register $r0

Legalizing: t9: i32 = FrameIndex<1>
Legal node: nothing to do

Combining: t9: i32 = FrameIndex<1>

Legalizing: t7: i32 = undef
Legal node: nothing to do

Combining: t7: i32 = undef

Legalizing: t5: i32 = FrameIndex<0>
Legal node: nothing to do

Combining: t5: i32 = FrameIndex<0>

Legalizing: t3: i32 = Register %1

Combining: t3: i32 = Register %1

Legalizing: t1: i32 = Register %0

Combining: t1: i32 = Register %0

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.0 '_Z9getNumberii:entry'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t8: ch = store<(store (s32) into %ir.x.addr)> t0, t2, FrameIndex:i32<0>, undef:i32
    t4: i32,ch = CopyFromReg t0, Register:i32 %1
  t10: ch = store<(store (s32) into %ir.y.addr)> t8, t4, FrameIndex:i32<1>, undef:i32
      t11: i32,ch = load<(dereferenceable load (s32) from %ir.x.addr)> t10, FrameIndex:i32<0>, undef:i32
      t12: i32,ch = load<(dereferenceable load (s32) from %ir.y.addr)> t10, FrameIndex:i32<1>, undef:i32
    t13: i32 = add nsw t11, t12
  t15: ch,glue = CopyToReg t10, Register:i32 $r0, t13
  t16: ch = TinyGPUISD::Ret t15, Register:i32 $r0, t15:1


Writing '/tmp/dag._Z9getNumberii-c250fe.dot'...  done. 
Trying 'xdg-open' program... Remember to erase graph file: /tmp/dag._Z9getNumberii-c250fe.dot
===== Instruction selection begins: %bb.0 'entry'

ISEL: Starting selection on root node: t16: ch = TinyGPUISD::Ret t15, Register:i32 $r0, t15:1
ISEL: Starting pattern match
  Morphed node: t16: ch = PseudoRET Register:i32 $r0, t15, t15:1
ISEL: Match complete!

ISEL: Starting selection on root node: t15: ch,glue = CopyToReg t10, Register:i32 $r0, t13

ISEL: Starting selection on root node: t13: i32 = add nsw t11, t12
ISEL: Starting pattern match
  Initial Opcode index to 95
  Match failed at index 100
  Continuing at 119
  Morphed node: t13: i32 = ADD nsw t11, t12
ISEL: Match complete!

ISEL: Starting selection on root node: t11: i32,ch = load<(dereferenceable load (s32) from %ir.x.addr)> t10, FrameIndex:i32<0>, undef:i32
ISEL: Starting pattern match
  Initial Opcode index to 254
  Morphed node: t11: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.x.addr)> FrameIndex:i32<0>, t10
ISEL: Match complete!

ISEL: Starting selection on root node: t12: i32,ch = load<(dereferenceable load (s32) from %ir.y.addr)> t10, FrameIndex:i32<1>, undef:i32
ISEL: Starting pattern match
  Initial Opcode index to 254
  Morphed node: t12: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.y.addr)> FrameIndex:i32<1>, t10
ISEL: Match complete!

ISEL: Starting selection on root node: t10: ch = store<(store (s32) into %ir.y.addr)> t8, t4, FrameIndex:i32<1>, undef:i32
ISEL: Starting pattern match
  Initial Opcode index to 53
  Match failed at index 59
  Continuing at 77
  Morphed node: t10: ch = STR<Mem:(store (s32) into %ir.y.addr)> t4, FrameIndex:i32<1>, t8
ISEL: Match complete!

ISEL: Starting selection on root node: t8: ch = store<(store (s32) into %ir.x.addr)> t0, t2, FrameIndex:i32<0>, undef:i32
ISEL: Starting pattern match
  Initial Opcode index to 53
  Match failed at index 59
  Continuing at 77
  Morphed node: t8: ch = STR<Mem:(store (s32) into %ir.x.addr)> t2, FrameIndex:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i32,ch = CopyFromReg t0, Register:i32 %1

ISEL: Starting selection on root node: t2: i32,ch = CopyFromReg t0, Register:i32 %0

ISEL: Starting selection on root node: t14: i32 = Register $r0

ISEL: Starting selection on root node: t9: i32 = FrameIndex<1>
ISEL: Starting pattern match
  Initial Opcode index to 517
Creating constant: t18: i32 = TargetConstant<0>
Creating new machine node: t19: i32 = I_ALLOCA TargetConstant:i32<0>
  Created node: t19: i32 = I_ALLOCA TargetConstant:i32<0>
  Morphed node: t9: i32 = ADD TargetFrameIndex:i32<1>, t19
ISEL: Match complete!

ISEL: Starting selection on root node: t5: i32 = FrameIndex<0>
ISEL: Starting pattern match
  Initial Opcode index to 517
  Created node: t19: i32 = I_ALLOCA TargetConstant:i32<0>
  Morphed node: t5: i32 = ADD TargetFrameIndex:i32<0>, t19
ISEL: Match complete!

ISEL: Starting selection on root node: t3: i32 = Register %1

ISEL: Starting selection on root node: t1: i32 = Register %0

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:

Selected selection DAG: %bb.0 '_Z9getNumberii:entry'
SelectionDAG has 19 nodes:
  t0: ch,glue = EntryToken
  t5: i32 = ADD TargetFrameIndex:i32<0>, t19
  t9: i32 = ADD TargetFrameIndex:i32<1>, t19
    t4: i32,ch = CopyFromReg t0, Register:i32 %1
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t8: ch = STR<Mem:(store (s32) into %ir.x.addr)> t2, t5, t0
  t10: ch = STR<Mem:(store (s32) into %ir.y.addr)> t4, t9, t8
      t11: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.x.addr)> t5, t10
      t12: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.y.addr)> t9, t10
    t13: i32 = ADD nsw t11, t12
  t15: ch,glue = CopyToReg t10, Register:i32 $r0, t13
  t19: i32 = I_ALLOCA TargetConstant:i32<0>
  t16: ch = PseudoRET Register:i32 $r0, t15, t15:1


********** List Scheduling %bb.0 'entry' **********
SU(0): t16: ch = PseudoRET Register:i32 $r0, t15, t15:1

    t15: ch,glue = CopyToReg t10, Register:i32 $r0, t13

  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 0
  Predecessors:
    SU(7): Ord  Latency=1 Barrier
    SU(1): Data Latency=1
SU(1): t13: i32 = ADD nsw t11, t12

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 1
  Predecessors:
    SU(5): Data Latency=1
    SU(2): Data Latency=1
  Successors:
    SU(0): Data Latency=1
SU(2): t12: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.y.addr)> t9, t10

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
    SU(7): Ord  Latency=1 Barrier
  Successors:
    SU(1): Data Latency=1
SU(3): t9: i32 = ADD TargetFrameIndex:i32<1>, t19

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(2): Data Latency=1
    SU(7): Data Latency=1
SU(4): t19: i32 = I_ALLOCA TargetConstant:i32<0>

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(3): Data Latency=1
    SU(6): Data Latency=1
SU(5): t11: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.x.addr)> t5, t10

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 2
  Predecessors:
    SU(6): Data Latency=1
    SU(7): Ord  Latency=1 Barrier
  Successors:
    SU(1): Data Latency=1
SU(6): t5: i32 = ADD TargetFrameIndex:i32<0>, t19

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(5): Data Latency=1
    SU(8): Data Latency=1
SU(7): t10: ch = STR<Mem:(store (s32) into %ir.y.addr)> t4, t9, t8

  # preds left       : 3
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 3
  Predecessors:
    SU(10): Data Latency=1
    SU(3): Data Latency=1
    SU(8): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
    SU(2): Ord  Latency=1 Barrier
    SU(5): Ord  Latency=1 Barrier
SU(8): t8: ch = STR<Mem:(store (s32) into %ir.x.addr)> t2, t5, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 4
  Predecessors:
    SU(9): Data Latency=1
    SU(6): Data Latency=1
  Successors:
    SU(7): Ord  Latency=1 Barrier
SU(9): t2: i32,ch = CopyFromReg t0, Register:i32 %0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(8): Data Latency=1
SU(10): t4: i32,ch = CopyFromReg t0, Register:i32 %1

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(7): Data Latency=1

Examining Available:
Height 0: SU(0): t16: ch = PseudoRET Register:i32 $r0, t15, t15:1

    t15: ch,glue = CopyToReg t10, Register:i32 $r0, t13


*** Scheduling [0]: SU(0): t16: ch = PseudoRET Register:i32 $r0, t15, t15:1

    t15: ch,glue = CopyToReg t10, Register:i32 $r0, t13


Examining Available:
Height 1: SU(1): t13: i32 = ADD nsw t11, t12


*** Scheduling [1]: SU(1): t13: i32 = ADD nsw t11, t12


Examining Available:
Height 2: SU(2): t12: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.y.addr)> t9, t10

Height 2: SU(5): t11: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.x.addr)> t5, t10


*** Scheduling [2]: SU(2): t12: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.y.addr)> t9, t10


Examining Available:
Height 2: SU(5): t11: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.x.addr)> t5, t10


*** Scheduling [3]: SU(5): t11: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.x.addr)> t5, t10


Examining Available:
Height 4: SU(7): t10: ch = STR<Mem:(store (s32) into %ir.y.addr)> t4, t9, t8


*** Scheduling [4]: SU(7): t10: ch = STR<Mem:(store (s32) into %ir.y.addr)> t4, t9, t8


Examining Available:
Height 5: SU(3): t9: i32 = ADD TargetFrameIndex:i32<1>, t19

Height 5: SU(8): t8: ch = STR<Mem:(store (s32) into %ir.x.addr)> t2, t5, t0

Height 5: SU(10): t4: i32,ch = CopyFromReg t0, Register:i32 %1


*** Scheduling [5]: SU(3): t9: i32 = ADD TargetFrameIndex:i32<1>, t19


Examining Available:
Height 5: SU(8): t8: ch = STR<Mem:(store (s32) into %ir.x.addr)> t2, t5, t0

Height 5: SU(10): t4: i32,ch = CopyFromReg t0, Register:i32 %1


*** Scheduling [6]: SU(8): t8: ch = STR<Mem:(store (s32) into %ir.x.addr)> t2, t5, t0


Examining Available:
Height 7: SU(6): t5: i32 = ADD TargetFrameIndex:i32<0>, t19

Height 7: SU(9): t2: i32,ch = CopyFromReg t0, Register:i32 %0

Height 5: SU(10): t4: i32,ch = CopyFromReg t0, Register:i32 %1


*** Scheduling [7]: SU(6): t5: i32 = ADD TargetFrameIndex:i32<0>, t19


Examining Available:
Height 8: SU(4): t19: i32 = I_ALLOCA TargetConstant:i32<0>

Height 7: SU(9): t2: i32,ch = CopyFromReg t0, Register:i32 %0

Height 5: SU(10): t4: i32,ch = CopyFromReg t0, Register:i32 %1


*** Scheduling [8]: SU(4): t19: i32 = I_ALLOCA TargetConstant:i32<0>


Examining Available:
Height 7: SU(9): t2: i32,ch = CopyFromReg t0, Register:i32 %0

Height 5: SU(10): t4: i32,ch = CopyFromReg t0, Register:i32 %1


*** Scheduling [9]: SU(9): t2: i32,ch = CopyFromReg t0, Register:i32 %0


Examining Available:
Height 5: SU(10): t4: i32,ch = CopyFromReg t0, Register:i32 %1


*** Scheduling [10]: SU(10): t4: i32,ch = CopyFromReg t0, Register:i32 %1

*** Final schedule ***
SU(10): t4: i32,ch = CopyFromReg t0, Register:i32 %1

SU(9): t2: i32,ch = CopyFromReg t0, Register:i32 %0

SU(4): t19: i32 = I_ALLOCA TargetConstant:i32<0>

SU(6): t5: i32 = ADD TargetFrameIndex:i32<0>, t19

SU(8): t8: ch = STR<Mem:(store (s32) into %ir.x.addr)> t2, t5, t0

SU(3): t9: i32 = ADD TargetFrameIndex:i32<1>, t19

SU(7): t10: ch = STR<Mem:(store (s32) into %ir.y.addr)> t4, t9, t8

SU(5): t11: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.x.addr)> t5, t10

SU(2): t12: i32,ch = LDR<Mem:(dereferenceable load (s32) from %ir.y.addr)> t9, t10

SU(1): t13: i32 = ADD nsw t11, t12

SU(0): t16: ch = PseudoRET Register:i32 $r0, t15, t15:1

    t15: ch,glue = CopyToReg t10, Register:i32 $r0, t13


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function _Z9getNumberii: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP]
  fi#1: size=4, align=4, at location [SP]
Function Live Ins: $r0 in %0, $r1 in %1

bb.0.entry:
  liveins: $r0, $r1
  %1:gpr = COPY $r1
  %0:gpr = COPY $r0
  %2:gpr = I_ALLOCA 0
  %3:gpr = ADD %stack.0.x.addr, %2:gpr
  STR %0:gpr, %3:gpr :: (store (s32) into %ir.x.addr)
  %4:gpr = ADD %stack.1.y.addr, %2:gpr
  STR %1:gpr, %4:gpr :: (store (s32) into %ir.y.addr)
  %5:gpr = LDR %3:gpr :: (dereferenceable load (s32) from %ir.x.addr)
  %6:gpr = LDR %4:gpr :: (dereferenceable load (s32) from %ir.y.addr)
  %7:gpr = nsw ADD killed %5:gpr, killed %6:gpr
  $r0 = COPY %7:gpr
  PseudoRET implicit $r0

# End machine code for function _Z9getNumberii.

Skipping pass 'Two-Address instruction pass' on function _Z9getNumberii
********** REWRITING TWO-ADDR INSTRS **********
********** Function: _Z9getNumberii
********** FAST REGISTER ALLOCATION **********
********** Function: _Z9getNumberii

Allocating bb.0.entry:
  liveins: $r0, $r1
  %1:gpr = COPY $r1
  %0:gpr = COPY $r0
  %2:gpr = I_ALLOCA 0
  %3:gpr = ADD %stack.0.x.addr, %2:gpr
  STR %0:gpr, %3:gpr :: (store (s32) into %ir.x.addr)
  %4:gpr = ADD %stack.1.y.addr, %2:gpr
  STR %1:gpr, %4:gpr :: (store (s32) into %ir.y.addr)
  %5:gpr = LDR %3:gpr :: (dereferenceable load (s32) from %ir.x.addr)
  %6:gpr = LDR %4:gpr :: (dereferenceable load (s32) from %ir.y.addr)
  %7:gpr = nsw ADD killed %5:gpr, killed %6:gpr
  $r0 = COPY %7:gpr
  PseudoRET implicit $r0

>> PseudoRET implicit $r0
Regs:
<< PseudoRET implicit killed $r0

>> $r0 = COPY %7:gpr
Regs: R0[P]
Freeing $r0:
Search register for %7 in class GPR with hint $r0
	Preferred Register 1: $r0
Assigning %7 to $r0
<< $r0 = COPY killed $r0
Mark identity copy for removal

>> %7:gpr = nsw ADD killed %5:gpr, killed %6:gpr
Regs: R0=%7
In def of %7 use existing assignment to $r0
Freeing $r0: %7
Search register for %5 in class GPR with hint $noreg
AllocationOrder(GPR) = [ $r0 $r1 $r2 $r3 $r4 $r5 $r6 $r7 $r10 $r8 $r9 ]
	Register: $r0 Cost: 0 BestCost: 4294967295
Assigning %5 to $r0
Search register for %6 in class GPR with hint $noreg
	Register: $r0 already used in instr.
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %6 to $r1
<< $r0 = nsw ADD killed $r0, killed $r1

>> %6:gpr = LDR %4:gpr :: (dereferenceable load (s32) from %ir.y.addr)
Regs: R0=%5 R1=%6
In def of %6 use existing assignment to $r1
Freeing $r1: %6
Search register for %4 in class GPR with hint $noreg
	Register: $r0 Cost: 100 BestCost: 4294967295
	Register: $r1 Cost: 0 BestCost: 100
Assigning %4 to $r1
<< $r1 = LDR killed $r1 :: (dereferenceable load (s32) from %ir.y.addr)

>> %5:gpr = LDR %3:gpr :: (dereferenceable load (s32) from %ir.x.addr)
Regs: R0=%5 R1=%4
In def of %5 use existing assignment to $r0
Freeing $r0: %5
Search register for %3 in class GPR with hint $noreg
	Register: $r0 Cost: 0 BestCost: 4294967295
Assigning %3 to $r0
<< $r0 = LDR killed $r0 :: (dereferenceable load (s32) from %ir.x.addr)

>> STR %1:gpr, %4:gpr :: (store (s32) into %ir.y.addr)
Regs: R0=%3 R1=%4
Search register for %1 in class GPR with hint $noreg
	Preferred Register 1: $r1 occupied
	Register: $r0 Cost: 100 BestCost: 4294967295
	Register: $r1 Cost: 100 BestCost: 100
	Register: $r2 Cost: 0 BestCost: 80
Assigning %1 to $r2
<< STR killed $r2, $r1 :: (store (s32) into %ir.y.addr)

>> %4:gpr = ADD %stack.1.y.addr, %2:gpr
Regs: R0=%3 R1=%4 R2=%1
In def of %4 use existing assignment to $r1
Freeing $r1: %4
Search register for %2 in class GPR with hint $noreg
	Register: $r0 Cost: 100 BestCost: 4294967295
	Register: $r1 Cost: 0 BestCost: 100
Assigning %2 to $r1
<< $r1 = ADD %stack.1.y.addr, killed $r1

>> STR %0:gpr, %3:gpr :: (store (s32) into %ir.x.addr)
Regs: R0=%3 R1=%2 R2=%1
Search register for %0 in class GPR with hint $noreg
	Preferred Register 1: $r0 occupied
	Register: $r0 Cost: 100 BestCost: 4294967295
	Register: $r1 Cost: 100 BestCost: 80
	Register: $r2 Cost: 100 BestCost: 80
	Register: $r3 Cost: 0 BestCost: 80
Assigning %0 to $r3
<< STR killed $r3, $r0 :: (store (s32) into %ir.x.addr)

>> %3:gpr = ADD %stack.0.x.addr, %2:gpr
Regs: R0=%3 R1=%2 R2=%1 R3=%0
In def of %3 use existing assignment to $r0
Freeing $r0: %3
<< $r0 = ADD %stack.0.x.addr, $r1

>> %2:gpr = I_ALLOCA 0
Regs: R1=%2 R2=%1 R3=%0
In def of %2 use existing assignment to $r1
Freeing $r1: %2
<< $r1 = I_ALLOCA 0

>> %0:gpr = COPY $r0
Regs: R2=%1 R3=%0
In def of %0 use existing assignment to $r3
Freeing $r3: %0
<< $r3 = COPY killed $r0

>> %1:gpr = COPY $r1
Regs: R0[P] R2=%1
In def of %1 use existing assignment to $r2
Freeing $r2: %1
<< $r2 = COPY killed $r1
Begin Regs: R0[P] R1[P]
Loading live registers at begin of block.
bb.0.entry:
  liveins: $r0, $r1
  $r2 = COPY killed $r1
  $r3 = COPY killed $r0
  $r1 = I_ALLOCA 0
  $r0 = ADD %stack.0.x.addr, $r1
  STR killed $r3, $r0 :: (store (s32) into %ir.x.addr)
  $r1 = ADD %stack.1.y.addr, killed $r1
  STR killed $r2, $r1 :: (store (s32) into %ir.y.addr)
  $r0 = LDR killed $r0 :: (dereferenceable load (s32) from %ir.x.addr)
  $r1 = LDR killed $r1 :: (dereferenceable load (s32) from %ir.y.addr)
  $r0 = nsw ADD killed $r0, killed $r1
  PseudoRET implicit killed $r0
Skipping pass 'Fixup Statepoint Caller Saved' on function _Z9getNumberii
alloc FI(0) at SP[-4]
alloc FI(1) at SP[-8]
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: _Z9getNumberii

Debug Range Extension: _Z9getNumberii
[SafeStack] Function: _Z13callGetNumberv
[SafeStack]     safestack is not requested for this function
Skipping pass 'CPU0 DAG->DAG Pattern Instruction Selection' on function _Z13callGetNumberv
	FastISel is enabled



=== _Z13callGetNumberv
Enabling fast-isel

Initial selection DAG: %bb.0 '_Z13callGetNumberv:entry'
SelectionDAG has 1 nodes:
  t0: ch,glue = EntryToken



Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.0 '_Z13callGetNumberv:entry'
SelectionDAG has 1 nodes:
  t0: ch,glue = EntryToken



Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t65535: ch = handlenode t0
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t65535: ch = handlenode t0

Type-legalized selection DAG: %bb.0 '_Z13callGetNumberv:entry'
SelectionDAG has 1 nodes:
  t0: ch,glue = EntryToken



Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.0 '_Z13callGetNumberv:entry'
SelectionDAG has 1 nodes:
  t0: ch,glue = EntryToken



Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.0 '_Z13callGetNumberv:entry'
SelectionDAG has 1 nodes:
  t0: ch,glue = EntryToken


Writing '/tmp/dag._Z13callGetNumberv-66604e.dot'...  done. 
Trying 'xdg-open' program... Remember to erase graph file: /tmp/dag._Z13callGetNumberv-66604e.dot
===== Instruction selection begins: %bb.0 'entry'

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:

Selected selection DAG: %bb.0 '_Z13callGetNumberv:entry'
SelectionDAG has 1 nodes:
  t0: ch,glue = EntryToken


********** List Scheduling %bb.0 'entry' **********
*** Final schedule ***

Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function _Z13callGetNumberv: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP]
  fi#1: size=4, align=4, at location [SP]

bb.0.entry:

# End machine code for function _Z13callGetNumberv.

Skipping pass 'Two-Address instruction pass' on function _Z13callGetNumberv
********** REWRITING TWO-ADDR INSTRS **********
********** Function: _Z13callGetNumberv
********** FAST REGISTER ALLOCATION **********
********** Function: _Z13callGetNumberv

Allocating bb.0.entry:
Begin Regs:
Loading live registers at begin of block.
bb.0.entry:
Skipping pass 'Fixup Statepoint Caller Saved' on function _Z13callGetNumberv
alloc FI(0) at SP[-4]
alloc FI(1) at SP[-8]
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: _Z13callGetNumberv

Debug Range Extension: _Z13callGetNumberv
